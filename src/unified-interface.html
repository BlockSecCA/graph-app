<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Causal Graph Tool</title>
    
    <!-- External Dependencies -->
    <script src="https://unpkg.com/vis-network@latest/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.3/full/pyodide.js"></script>
    
    <!-- Application Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
        }

        /* Top Toolbar */
        .toolbar {
            height: 60px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .toolbar h1 {
            font-size: 18px;
            margin-right: 30px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-section:not(:last-child) {
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #34495e;
        }

        .toolbar button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .toolbar button:hover {
            background: #2980b9;
        }

        .toolbar button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .toolbar select {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
            font-size: 14px;
        }

        .toolbar input[type="file"] {
            display: none;
        }

        .toolbar label {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .toolbar label:hover {
            background: #229954;
        }

        .toolbar-input {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            min-width: 80px;
        }

        .toolbar-input.small {
            min-width: 60px;
            max-width: 80px;
        }

        .toolbar-select {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            min-width: 50px;
        }

        .toolbar button.danger {
            background: #e74c3c;
        }

        .toolbar button.danger:hover {
            background: #c0392b;
        }

        /* Main Content Area */
        .main-content {
            height: calc(100vh - 60px);
            display: flex;
        }

        /* Split Pane Container */
        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Editor Pane */
        .editor-pane {
            flex: 1;
            min-width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            position: relative;  /* Ensure controls stay within pane */
        }

        .editor-header {
            padding: 15px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            font-weight: 600;
            color: #2c3e50;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-header h2 {
            margin: 0;
        }

        .prefs-toggle {
            background: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .prefs-toggle:hover {
            background: #2980b9;
        }

        /* Visualization Preferences Panel */
        .viz-preferences {
            background: #f8f9fa;
            border-bottom: 1px solid #ddd;
            padding: 20px;
            display: none; /* Hidden by default */
        }

        .viz-preferences.expanded {
            display: block;
        }

        .pref-section {
            margin-bottom: 20px;
        }

        .pref-section:last-child {
            margin-bottom: 0;
        }

        .pref-section h4 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #2c3e50;
            font-weight: 600;
        }

        .pref-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
        }

        .pref-control:last-child {
            margin-bottom: 0;
        }

        .pref-label {
            min-width: 120px;
            font-size: 13px;
            color: #555;
        }

        .pref-slider {
            flex: 1;
            max-width: 150px;
        }

        .pref-value {
            min-width: 40px;
            font-size: 13px;
            color: #666;
            font-weight: 500;
        }

        .pref-checkbox {
            margin-right: 6px;
        }

        .pref-select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 13px;
        }

        .pref-reset-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-top: 10px;
        }

        .pref-reset-btn:hover {
            background: #c0392b;
        }


        .vis-network {
            flex: 1;
            width: 100%;
            background: white;
        }

        /* Resizable Splitter */
        .splitter {
            width: 5px;
            background: #bdc3c7;
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
        }

        .splitter:hover {
            background: #95a5a6;
        }

        .splitter::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 30px;
            background: #7f8c8d;
            border-radius: 2px;
        }

        /* Analysis Pane */
        .analysis-pane {
            flex: 1;
            min-width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .analysis-header {
            padding: 15px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .analysis-header h2 {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .plugin-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .plugin-selector select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .run-analysis-btn {
            padding: 8px 16px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .run-analysis-btn:hover {
            background: #229954;
        }

        .run-analysis-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        /* Analysis Results */
        .analysis-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .analysis-results {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .analysis-results h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .analysis-results pre {
            background: white;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Status Messages */
        .status-message {
            padding: 10px 15px;
            margin: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .split-container {
                flex-direction: column;
            }
            
            .splitter {
                width: 100%;
                height: 5px;
                cursor: row-resize;
            }
            
            .editor-pane,
            .analysis-pane {
                min-width: unset;
                min-height: 300px;
            }
            
            .toolbar {
                flex-wrap: wrap;
                height: auto;
                min-height: 60px;
            }
            
            .toolbar-section {
                margin-right: 15px;
                padding-right: 15px;
            }
        }


        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10000;
            min-width: 150px;
            padding: 4px 0;
            font-size: 14px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e74c3c;
        }

        .context-menu-item.danger:hover {
            background: #fdf2f2;
        }

        .context-menu-separator {
            height: 1px;
            background: #eee;
            margin: 4px 0;
        }

        /* Modal dialog styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .modal-dialog {
            background: white;
            border-radius: 6px;
            padding: 20px;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .modal-title {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .modal-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-button.primary {
            background: #3498db;
            color: white;
        }

        .modal-button.primary:hover {
            background: #2980b9;
        }

        .modal-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .modal-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Hide elements when not needed */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Top Toolbar -->
    <div class="toolbar">
        <div class="toolbar-section">
            <span>Nodes: <span id="node-count">0</span></span>
            <span>Edges: <span id="edge-count">0</span></span>
        </div>
        
        <div class="toolbar-section">
            <input type="file" id="file-input" accept=".json" style="display: none;">
            <button onclick="document.getElementById('file-input').click()">📂 Load Graph</button>
            <button onclick="saveGraphFile()">💾 Save Graph</button>
            <button onclick="fitGraphToView()">🔍 Fit to View</button>
        </div>
        
        <div class="toolbar-section">
            <span id="mode-indicator">Right-click canvas to add nodes</span>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="split-container">
            <!-- Editor Pane -->
            <div class="editor-pane">
                <div class="editor-header">
                    <h2>Graph Editor</h2>
                    <button id="prefs-toggle" class="prefs-toggle">⚙️ Visualization</button>
                </div>
                
                <!-- Visualization Preferences Panel -->
                <div id="viz-preferences" class="viz-preferences">
                    <div class="pref-section">
                        <h4>Node Settings</h4>
                        <div class="pref-control">
                            <label class="pref-label">Node Size:</label>
                            <input type="range" id="node-size-slider" class="pref-slider" min="8" max="32" step="2" value="16">
                            <span id="node-size-value" class="pref-value">16px</span>
                        </div>
                        <div class="pref-control">
                            <label class="pref-label">Auto-size nodes:</label>
                            <input type="checkbox" id="node-auto-size" class="pref-checkbox">
                            <span style="font-size: 12px; color: #777;">Size based on connections</span>
                        </div>
                    </div>
                    
                    <div class="pref-section">
                        <h4>Edge Settings</h4>
                        <div class="pref-control">
                            <label class="pref-label">Arrow Scale:</label>
                            <input type="range" id="arrow-scale-slider" class="pref-slider" min="0.5" max="2.5" step="0.1" value="1.2">
                            <span id="arrow-scale-value" class="pref-value">1.2x</span>
                        </div>
                        <div class="pref-control">
                            <label class="pref-label">Scale by value:</label>
                            <input type="checkbox" id="arrow-scale-by-value" class="pref-checkbox">
                            <span style="font-size: 12px; color: #777;">Arrow size reflects edge weight</span>
                        </div>
                        <div class="pref-control">
                            <label class="pref-label">Skinny arrows:</label>
                            <input type="checkbox" id="arrow-skinny-mode" class="pref-checkbox">
                            <span style="font-size: 12px; color: #777;">Use thinner arrow style</span>
                        </div>
                    </div>
                    
                    <div class="pref-section">
                        <h4>Layout Settings</h4>
                        <div class="pref-control">
                            <label class="pref-label">Node Spacing:</label>
                            <select id="physics-preset" class="pref-select">
                                <option value="tight">Tight</option>
                                <option value="normal" selected>Normal</option>
                                <option value="loose">Loose</option>
                            </select>
                        </div>
                        <div class="pref-control">
                            <label class="pref-label">Spring Length:</label>
                            <input type="range" id="spring-length-slider" class="pref-slider" min="50" max="200" step="5" value="95">
                            <span id="spring-length-value" class="pref-value">95px</span>
                        </div>
                    </div>
                    
                    <div style="text-align: center; border-top: 1px solid #ddd; padding-top: 15px;">
                        <button id="reset-defaults-btn" class="pref-reset-btn">🔄 Reset to Defaults</button>
                    </div>
                </div>
                
                <!-- Graph Network (takes full space) -->
                <div id="editor-network" class="vis-network"></div>
            </div>

            <!-- Resizable Splitter -->
            <div class="splitter" id="splitter"></div>

            <!-- Analysis Pane -->
            <div class="analysis-pane">
                <div class="analysis-header">
                    <h2>Analysis</h2>
                    <div class="plugin-selector">
                        <select id="plugin-select">
                            <option value="causal-paths">Causal Path Analysis</option>
                            <option value="centrality" disabled>Centrality (Coming Soon)</option>
                            <option value="community" disabled>Community Detection (Coming Soon)</option>
                        </select>
                        <button id="run-analysis" class="run-analysis-btn">Analyze</button>
                    </div>
                </div>
                
                <!-- Analysis Content -->
                <div class="analysis-content">
                    <div id="analysis-placeholder" class="analysis-results">
                        <h3>Ready to Analyze</h3>
                        <p>Create a graph in the editor and click "Analyze" to see results.</p>
                        <p>Analysis will run automatically as you make changes to the graph.</p>
                    </div>
                    
                    <div id="analysis-loading" class="loading hidden">
                        Analyzing graph...
                    </div>
                    
                    <div id="analysis-results" class="analysis-results hidden">
                        <h3>Analysis Results</h3>
                        <div id="results-content"></div>
                    </div>
                    
                    <!-- Graph Visualization for Analysis -->
                    <div id="analysis-visualization" class="graph-container hidden" data-container-type="analysis" style="height: 300px; margin-top: 20px;">
                        <div id="analysis-network" class="vis-network"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Messages Container -->
    <div id="status-container"></div>

    <!-- Hidden file input for menu operations -->
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <!-- Include Shared State -->
    <script src="shared-state.js"></script>

    <!-- Main Application Script -->
    <script>
        // Initialize the unified interface
        document.addEventListener('DOMContentLoaded', function() {
            console.log('🔧 DOM loaded, require available:', typeof window.require === 'function');
            initializeUnifiedInterface();
            
            // Set up IPC listeners for menu commands
            if (window.require) {
                try {
                    const { ipcRenderer } = window.require('electron');
                    console.log('IPC Renderer available, setting up menu listeners...');
                    
                    ipcRenderer.on('menu-load-graph-content', (event, fileContent, fileName) => {
                        console.log('Menu: Load Graph content received');
                        try {
                            window.graphApp.importGraph(fileContent);
                            showStatus(`Graph loaded from "${fileName}"`, 'success');
                        } catch (error) {
                            showStatus(`Failed to load graph: ${error.message}`, 'error');
                        }
                    });
                    
                    ipcRenderer.on('menu-save-graph', () => {
                        console.log('Menu: Save Graph clicked');
                        saveGraphFile();
                    });
                    
                    ipcRenderer.on('menu-fit-graph', () => {
                        console.log('Menu: Fit Graph clicked');
                        const network = window.graphApp.networks.editor;
                        if (network) {
                            network.fit();
                        }
                    });
                    
                } catch (error) {
                    console.error('Failed to set up IPC listeners:', error);
                }
            } else {
                console.warn('require not available, menu shortcuts will not work');
            }
            
            // Set up direct file input handler (works without IPC)
            const fileInput = document.getElementById('file-input');
            if (fileInput) {
                fileInput.addEventListener('change', function(event) {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            try {
                                console.log('File loaded via input:', file.name);
                                window.graphApp.importGraph(e.target.result);
                                showStatus(`Graph loaded from "${file.name}"`, 'success');
                            } catch (error) {
                                console.error('Error loading file:', error);
                                showStatus(`Failed to load graph: ${error.message}`, 'error');
                            }
                        };
                        reader.readAsText(file);
                    }
                    // Reset input value so same file can be loaded again
                    event.target.value = '';
                });
            }
        });

        async function initializeUnifiedInterface() {
            console.log('Initializing Causal Graph Tool...');
            
            // Initialize shared state
            const app = window.graphApp;
            
            // Initialize networks
            initializeEditorNetwork();
            initializeSplitter();
            initializeEventHandlers();
            
            // Initialize analysis system (placeholder for now)
            await initializeAnalysisSystem();
            
            console.log('Application initialized successfully');
        }

        // Visualization Preferences Management
        function initializeVisualizationPreferences(network, options) {
            // Default preferences (matching current configuration)
            const defaultPrefs = {
                nodeSize: 16,
                nodeSizeAuto: false,
                arrowScale: 1.2,
                arrowScaleByValue: false,
                arrowSkinnyMode: false,
                springLength: 95,
                physicsPreset: 'normal'
            };

            // Load preferences from localStorage or use defaults
            function loadPreferences() {
                const saved = localStorage.getItem('graph-app-viz-preferences');
                return saved ? { ...defaultPrefs, ...JSON.parse(saved) } : defaultPrefs;
            }

            // Save preferences to localStorage
            function savePreferences(prefs) {
                localStorage.setItem('graph-app-viz-preferences', JSON.stringify(prefs));
            }

            // Apply preferences to network
            function applyPreferences(prefs) {
                const newOptions = {
                    nodes: {
                        ...options.nodes,
                        size: prefs.nodeSizeAuto ? undefined : prefs.nodeSize
                    },
                    edges: {
                        ...options.edges,
                        arrows: { 
                            to: { 
                                enabled: true, 
                                scaleFactor: prefs.arrowScale 
                            } 
                        },
                        width: prefs.arrowScale * (prefs.arrowSkinnyMode ? 1 : 2)  // Skinny mode uses 1, normal uses 2
                    },
                    physics: {
                        ...options.physics,
                        barnesHut: {
                            ...options.physics.barnesHut,
                            springLength: prefs.springLength,
                            ...(prefs.physicsPreset === 'tight' && {
                                gravitationalConstant: -3000,
                                centralGravity: 0.5,
                                springLength: prefs.springLength * 0.7
                            }),
                            ...(prefs.physicsPreset === 'loose' && {
                                gravitationalConstant: -1000,
                                centralGravity: 0.1,
                                springLength: prefs.springLength * 1.3
                            })
                        }
                    }
                };

                network.setOptions(newOptions);

                // Handle node sizing
                if (prefs.nodeSizeAuto) {
                    updateAutoSizedNodes(network);
                } else {
                    // Reset all nodes to uniform manual size
                    resetNodesToUniformSize(network, prefs.nodeSize);
                }

                // Handle arrow scaling
                if (prefs.arrowScaleByValue) {
                    updateValueBasedArrows(network, prefs.arrowScale, prefs.arrowSkinnyMode);
                } else {
                    // Reset all arrows to uniform scale
                    resetArrowsToUniformScale(network, prefs.arrowScale, prefs.arrowSkinnyMode);
                }
            }

            // Update node sizes based on connections
            function updateAutoSizedNodes(network) {
                const nodes = network.body.data.nodes;
                const edges = network.body.data.edges;
                
                if (nodes && edges) {
                    const nodeConnections = {};
                    edges.forEach(edge => {
                        nodeConnections[edge.from] = (nodeConnections[edge.from] || 0) + 1;
                        nodeConnections[edge.to] = (nodeConnections[edge.to] || 0) + 1;
                    });

                    const updates = nodes.map(node => ({
                        id: node.id,
                        size: Math.max(12, Math.min(32, 8 + (nodeConnections[node.id] || 0) * 3))
                    }));

                    nodes.update(updates);
                }
            }

            // Update arrow sizes based on edge values
            function updateValueBasedArrows(network, baseScale, skinnyMode = false) {
                const edges = network.body.data.edges;
                
                if (edges) {
                    const values = edges.map(edge => Math.abs(parseFloat(edge.value) || 1));
                    const maxValue = Math.max(...values);
                    const minValue = Math.min(...values);
                    const valueRange = maxValue - minValue || 1;

                    const updates = edges.map(edge => {
                        const value = Math.abs(parseFloat(edge.value) || 1);
                        const normalizedValue = (value - minValue) / valueRange;
                        const scaleFactor = baseScale * (0.5 + normalizedValue * 1.5); // 0.5x to 2x range
                        
                        return {
                            id: edge.id,
                            arrows: { to: { enabled: true, scaleFactor } },
                            width: scaleFactor * (skinnyMode ? 1 : 2)  // Scale body width proportionally
                        };
                    });

                    edges.update(updates);
                }
            }

            // Reset all nodes to uniform manual size
            function resetNodesToUniformSize(network, uniformSize) {
                const nodes = network.body.data.nodes;
                
                if (nodes) {
                    const updates = nodes.map(node => ({
                        id: node.id,
                        size: uniformSize
                    }));

                    nodes.update(updates);
                }
            }

            // Reset all arrows to uniform scale
            function resetArrowsToUniformScale(network, uniformScale, skinnyMode = false) {
                const edges = network.body.data.edges;
                
                if (edges) {
                    const updates = edges.map(edge => ({
                        id: edge.id,
                        arrows: { to: { enabled: true, scaleFactor: uniformScale } },
                        width: uniformScale * (skinnyMode ? 1 : 2)  // Reset body width to uniform scale
                    }));

                    edges.update(updates);
                }
            }

            // Initialize preferences panel
            const prefsToggle = document.getElementById('prefs-toggle');
            const prefsPanel = document.getElementById('viz-preferences');
            
            // Load and apply initial preferences
            let currentPrefs = loadPreferences();
            updateUI(currentPrefs);
            applyPreferences(currentPrefs);

            // Toggle panel visibility
            prefsToggle.addEventListener('click', () => {
                prefsPanel.classList.toggle('expanded');
                prefsToggle.textContent = prefsPanel.classList.contains('expanded') 
                    ? '⚙️ Hide Preferences' 
                    : '⚙️ Visualization';
            });

            // Update UI controls with current preferences
            function updateUI(prefs) {
                document.getElementById('node-size-slider').value = prefs.nodeSize;
                document.getElementById('node-size-value').textContent = prefs.nodeSize + 'px';
                document.getElementById('node-auto-size').checked = prefs.nodeSizeAuto;
                
                document.getElementById('arrow-scale-slider').value = prefs.arrowScale;
                document.getElementById('arrow-scale-value').textContent = prefs.arrowScale + 'x';
                document.getElementById('arrow-scale-by-value').checked = prefs.arrowScaleByValue;
                document.getElementById('arrow-skinny-mode').checked = prefs.arrowSkinnyMode;
                
                document.getElementById('physics-preset').value = prefs.physicsPreset;
                document.getElementById('spring-length-slider').value = prefs.springLength;
                document.getElementById('spring-length-value').textContent = prefs.springLength + 'px';
            }

            // Set up event listeners for all controls
            document.getElementById('node-size-slider').addEventListener('input', (e) => {
                currentPrefs.nodeSize = parseInt(e.target.value);
                document.getElementById('node-size-value').textContent = currentPrefs.nodeSize + 'px';
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            document.getElementById('node-auto-size').addEventListener('change', (e) => {
                currentPrefs.nodeSizeAuto = e.target.checked;
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            document.getElementById('arrow-scale-slider').addEventListener('input', (e) => {
                currentPrefs.arrowScale = parseFloat(e.target.value);
                document.getElementById('arrow-scale-value').textContent = currentPrefs.arrowScale + 'x';
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            document.getElementById('arrow-scale-by-value').addEventListener('change', (e) => {
                currentPrefs.arrowScaleByValue = e.target.checked;
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            document.getElementById('arrow-skinny-mode').addEventListener('change', (e) => {
                currentPrefs.arrowSkinnyMode = e.target.checked;
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            document.getElementById('physics-preset').addEventListener('change', (e) => {
                currentPrefs.physicsPreset = e.target.value;
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            document.getElementById('spring-length-slider').addEventListener('input', (e) => {
                currentPrefs.springLength = parseInt(e.target.value);
                document.getElementById('spring-length-value').textContent = currentPrefs.springLength + 'px';
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            // Reset to defaults button
            document.getElementById('reset-defaults-btn').addEventListener('click', () => {
                // Reset to original v2.0 defaults
                currentPrefs = { ...defaultPrefs };
                updateUI(currentPrefs);
                savePreferences(currentPrefs);
                applyPreferences(currentPrefs);
            });

            // Re-apply preferences when graph data changes
            network.on('stabilizationIterationsDone', () => {
                if (currentPrefs.nodeSizeAuto) {
                    updateAutoSizedNodes(network);
                }
                if (currentPrefs.arrowScaleByValue) {
                    updateValueBasedArrows(network, currentPrefs.arrowScale);
                }
            });

            // Return functions for external access
            return {
                applyPreferences: () => applyPreferences(currentPrefs),
                updateAutoSizedNodes: () => updateAutoSizedNodes(network),
                updateValueBasedArrows: () => updateValueBasedArrows(network, currentPrefs.arrowScale, currentPrefs.arrowSkinnyMode),
                resetNodesToUniformSize: () => resetNodesToUniformSize(network, currentPrefs.nodeSize),
                resetArrowsToUniformScale: () => resetArrowsToUniformScale(network, currentPrefs.arrowScale, currentPrefs.arrowSkinnyMode),
                getCurrentPrefs: () => currentPrefs
            };
        }

        function initializeEditorNetwork() {
            const container = document.getElementById('editor-network');
            
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: { color: '#2c3e50', size: 14 },
                    borderWidth: 2,
                    shadow: true
                },
                edges: {
                    arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                    smooth: { type: 'curvedCW', roundness: 0.1 },
                    font: { color: '#34495e', size: 12, align: 'middle' },
                    shadow: true
                },
                physics: {
                    enabled: true,
                    stabilization: { 
                        enabled: true,
                        iterations: 500,
                        updateInterval: 25
                    },
                    barnesHut: {
                        gravitationalConstant: -2000,
                        centralGravity: 0.3,
                        springLength: 95,
                        springConstant: 0.04,
                        damping: 0.09
                    }
                },
                // NO interaction config - use vis-network defaults for proper zoom/pan
                // Force vis-network to use full container size
                autoResize: true,
                width: '100%',
                height: '100%'
            };

            // Create the vis-network
            const editorNetwork = new vis.Network(container, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
            
            // Initialize visualization preferences
            const vizPrefs = initializeVisualizationPreferences(editorNetwork, options);
            
            // Store reference for graph updates
            editorNetwork._vizPrefs = vizPrefs;
            
            // Force resize to container dimensions
            function resizeNetwork() {
                const rect = container.getBoundingClientRect();
                editorNetwork.setSize(rect.width + 'px', rect.height + 'px');
                editorNetwork.fit();
            }
            
            // Initial resize
            setTimeout(resizeNetwork, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeNetwork);
            
            // Register with shared state
            window.graphApp.registerNetwork('editor', editorNetwork);
            
            // Listen for graph updates
            window.graphApp.addEventListener('graphUpdated', (e) => {
                updateNetworkData(editorNetwork, e.detail.graph);
                updateStats(e.detail.graph);
            });
            
            // Add context menu support
            setupContextMenus(editorNetwork);
        }

        function updateNetworkData(network, graphData) {
            console.log('Updating network with graph data:', graphData);
            
            // Always create fresh DataSets (identical to app startup behavior)
            const nodes = new vis.DataSet();
            const edges = new vis.DataSet();
            
            // Add new nodes
            const nodeData = graphData.nodes.map((node, index) => {
                const nodeData = {
                    id: node.id,
                    label: node.label || node.id,
                    group: node.group || 'default',
                    title: `${node.label || node.id}\nType: ${node.type || 'N/A'}\nGroup: ${node.group || 'default'}`,
                    // Use provided positions or let physics handle it
                    x: node.x,
                    y: node.y
                };
                console.log('Creating node for network:', nodeData);
                return nodeData;
            });
            
            // Add new edges
            const edgeData = graphData.edges.map(edge => ({
                id: `${edge.source}-${edge.target}`,
                from: edge.source,
                to: edge.target,
                label: edge.type + (edge.weight !== 1 ? ` (${edge.weight})` : ''),
                color: edge.type === '+' ? '#27ae60' : '#e74c3c',
                width: Math.abs(edge.weight) * 2,
                title: `${edge.source} → ${edge.target}\nType: ${edge.type}\nWeight: ${edge.weight}`
            }));
            
            // Add data to fresh datasets
            if (nodeData.length > 0) {
                nodes.add(nodeData);
            }
            if (edgeData.length > 0) {
                edges.add(edgeData);
            }
            
            // Update network with fresh DataSets (identical to app startup)
            network.setData({ nodes, edges });
            console.log('Network updated with fresh DataSets');
            
            // Ensure nodes are visible by fitting the view
            if (graphData.nodes.length > 0) {
                setTimeout(() => {
                    network.fit({
                        animation: {
                            duration: 1000,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                    
                    // Re-apply visualization preferences after data update
                    if (network._vizPrefs) {
                        const prefs = network._vizPrefs.getCurrentPrefs();
                        if (prefs.nodeSizeAuto) {
                            network._vizPrefs.updateAutoSizedNodes();
                        } else {
                            network._vizPrefs.resetNodesToUniformSize();
                        }
                        if (prefs.arrowScaleByValue) {
                            network._vizPrefs.updateValueBasedArrows();
                        } else {
                            network._vizPrefs.resetArrowsToUniformScale();
                        }
                    }
                }, 300);
            }
        }

        function updateStats(graphData) {
            document.getElementById('node-count').textContent = graphData.nodes.length;
            document.getElementById('edge-count').textContent = graphData.edges.length;
            
            // Debug: Log node positions
            if (graphData.nodes.length > 0) {
                console.log('Current nodes:', graphData.nodes);
                
                // Auto-fit if we have nodes but they might be invisible
                setTimeout(() => {
                    const network = window.graphApp.networks.editor;
                    if (network) {
                        network.fit();
                    }
                }, 200);
            }
        }

        function setupContextMenus(network) {
            let contextMenu = null;
            let contextPosition = { x: 0, y: 0 };
            let contextNodeId = null;
            let contextEdgeId = null;
            
            // Disable default context menu
            const container = document.getElementById('editor-network');
            console.log('Setting up context menu on container:', container);
            
            // Ensure network is fully initialized before setting up events
            network.once('stabilizationIterationsDone', () => {
                console.log('Network stabilized, context menus are ready');
            });
            
            // Disable default browser context menu
            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            
            // Use vis-network's oncontext event exclusively for better reliability
            network.on('oncontext', (params) => {
                console.log('vis-network oncontext event:', params);
                if (params.event && params.event.preventDefault) {
                    params.event.preventDefault();
                    
                    const canvasPosition = { x: params.pointer.canvas.x, y: params.pointer.canvas.y };
                    const domPosition = { x: params.pointer.DOM.x, y: params.pointer.DOM.y };
                    
                    console.log('Context menu triggered at DOM:', domPosition, 'Canvas:', canvasPosition);
                    
                    if (params.nodes && params.nodes.length > 0) {
                        console.log('Right-clicked on node:', params.nodes[0]);
                        showNodeContextMenu(domPosition.x, domPosition.y, params.nodes[0]);
                    } else if (params.edges && params.edges.length > 0) {
                        console.log('Right-clicked on edge:', params.edges[0]);
                        showEdgeContextMenu(domPosition.x, domPosition.y, params.edges[0]);
                    } else {
                        console.log('Right-clicked on canvas, showing add node menu');
                        showCanvasContextMenu(domPosition.x, domPosition.y, canvasPosition);
                    }
                }
            });
            
            // Close context menu on click elsewhere (but not on modal dialogs)
            document.addEventListener('click', (e) => {
                // Don't close context menu if clicking on modal elements
                if (!e.target.closest('.modal-overlay') && !e.target.closest('.context-menu')) {
                    closeContextMenu();
                }
            });
            
            // Close context menu on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeContextMenu();
                }
            });
            
            function closeContextMenu() {
                if (contextMenu) {
                    document.body.removeChild(contextMenu);
                    contextMenu = null;
                }
            }
            
            function showCanvasContextMenu(x, y, canvasPosition) {
                closeContextMenu();
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const addNodeItem = document.createElement('button');
                addNodeItem.className = 'context-menu-item';
                addNodeItem.innerHTML = '➕ Add Node';
                addNodeItem.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    closeContextMenu();
                    // Small delay to ensure event handling is complete
                    setTimeout(() => {
                        showAddNodeDialog(canvasPosition);
                    }, 10);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const addEdgeItem = document.createElement('button');
                addEdgeItem.className = 'context-menu-item';
                addEdgeItem.innerHTML = '🔗 Add Edge';
                addEdgeItem.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    closeContextMenu();
                    // Small delay to ensure event handling is complete
                    setTimeout(() => {
                        showAddEdgeDialog();
                    }, 10);
                };
                
                contextMenu.appendChild(addNodeItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(addEdgeItem);
                document.body.appendChild(contextMenu);
            }
            
            function showNodeContextMenu(x, y, nodeId) {
                closeContextMenu();
                
                const node = window.graphApp.state.currentGraph.nodes.find(n => n.id === nodeId);
                if (!node) return;
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const editItem = document.createElement('button');
                editItem.className = 'context-menu-item';
                editItem.innerHTML = '✏️ Edit Node';
                editItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showEditNodeDialog(node);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const deleteItem = document.createElement('button');
                deleteItem.className = 'context-menu-item danger';
                deleteItem.innerHTML = '🗑️ Delete Node';
                deleteItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (confirm(`Delete node "${node.label || node.id}"?`)) {
                        window.graphApp.deleteNode(nodeId);
                        showStatus(`Node "${node.label || node.id}" deleted`, 'success');
                    }
                };
                
                contextMenu.appendChild(editItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(deleteItem);
                document.body.appendChild(contextMenu);
            }
            
            function showEdgeContextMenu(x, y, edgeId) {
                closeContextMenu();
                console.log('Looking for edge with ID:', edgeId);
                console.log('Available edges:', window.graphApp.state.currentGraph.edges);
                
                const edge = window.graphApp.state.currentGraph.edges.find(e => 
                    `${e.source}-${e.target}` === edgeId
                );
                console.log('Found edge:', edge);
                if (!edge) {
                    console.warn('Edge not found for ID:', edgeId);
                    return;
                }
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const editItem = document.createElement('button');
                editItem.className = 'context-menu-item';
                editItem.innerHTML = '✏️ Edit Edge';
                editItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showEditEdgeDialog(edge);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const deleteItem = document.createElement('button');
                deleteItem.className = 'context-menu-item danger';
                deleteItem.innerHTML = '🗑️ Delete Edge';
                deleteItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (confirm(`Delete edge "${edge.source} → ${edge.target}"?`)) {
                        window.graphApp.deleteEdge(edge.source, edge.target);
                        showStatus(`Edge "${edge.source} → ${edge.target}" deleted`, 'success');
                    }
                };
                
                contextMenu.appendChild(editItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(deleteItem);
                document.body.appendChild(contextMenu);
            }
        }

        function initializeSplitter() {
            const splitter = document.getElementById('splitter');
            const container = document.querySelector('.split-container');
            const editorPane = document.querySelector('.editor-pane');
            const analysisPane = document.querySelector('.analysis-pane');
            
            let isResizing = false;
            
            splitter.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const containerWidth = containerRect.width;
                
                // Calculate percentages
                const leftPercent = (x / containerWidth) * 100;
                const rightPercent = 100 - leftPercent;
                
                // Enforce minimum widths (30% each)
                if (leftPercent >= 30 && rightPercent >= 30) {
                    editorPane.style.flex = `0 0 ${leftPercent}%`;
                    analysisPane.style.flex = `0 0 ${rightPercent}%`;
                    
                    // Trigger network resize and control adaptation
                    setTimeout(() => {
                        const editorNetwork = window.graphApp.networks.editor;
                        const analysisNetwork = window.graphApp.networks.analysis;
                        
                        if (editorNetwork) {
                            const editorContainer = document.getElementById('editor-network');
                            const rect = editorContainer.getBoundingClientRect();
                            editorNetwork.setSize(rect.width + 'px', rect.height + 'px');
                            editorNetwork.fit();
                        }
                        if (analysisNetwork) {
                            analysisNetwork.fit();
                        }
                    }, 50);
                }
            }
            
            function stopResize() {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }

        function saveGraphFile() {
            try {
                const jsonData = window.graphApp.exportGraph();
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'graph.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('Graph saved successfully', 'success');
            } catch (error) {
                showStatus(`Failed to save graph: ${error.message}`, 'error');
            }
        }

        function fitGraphToView() {
            try {
                if (window.graphApp && window.graphApp.networks && window.graphApp.networks.editor) {
                    window.graphApp.networks.editor.fit();
                    showStatus('Graph fitted to view', 'success');
                    console.log('Graph fitted to view via toolbar button');
                } else {
                    showStatus('Graph network not available for fitting', 'error');
                    console.log('Graph network not available for fitting');
                }
            } catch (error) {
                console.error('Error fitting graph:', error);
                showStatus('Failed to fit graph: ' + error.message, 'error');
            }
        }

        function showAddNodeDialog(canvasPosition) {
            console.log('showAddNodeDialog called with position:', canvasPosition);
            
            // Remove any existing modals first
            const existingModals = document.querySelectorAll('.modal-overlay');
            existingModals.forEach(modal => modal.remove());
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Add New Node</h3>
                <input type="text" id="modal-node-id" class="modal-input" placeholder="Node ID (required)" />
                <input type="text" id="modal-node-label" class="modal-input" placeholder="Node Label (optional)" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="createNode()">Add Node</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            console.log('Modal dialog created and added to DOM');
            
            // Handle overlay clicks - close modal if clicking overlay, prevent propagation otherwise
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    // Clicking the overlay itself (not the dialog)
                    closeModal();
                } else {
                    // Clicking something inside the dialog - prevent propagation
                    e.stopPropagation();
                }
            });
            
            
            // Focus the first input with better error handling
            setTimeout(() => {
                const input = document.getElementById('modal-node-id');
                if (input) {
                    input.focus();
                    input.select(); // Select text to make it obvious it's focused
                    console.log('Input focused and selected successfully');
                    
                    // Test if input works by adding a test listener
                    input.addEventListener('input', (e) => {
                        console.log('Input event detected:', e.target.value);
                    });
                    
                } else {
                    console.error('Could not find modal-node-id input element');
                }
            }, 150);
            
            // Handle enter key
            dialog.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createNode();
                }
            });
            
            window.closeModal = () => {
                if (overlay && overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
                delete window.closeModal;
                delete window.createNode;
                console.log('Modal closed and cleaned up');
            };
            
            window.createNode = () => {
                const id = document.getElementById('modal-node-id').value.trim();
                const label = document.getElementById('modal-node-label').value.trim();
                
                if (!id) {
                    showStatus('Please enter a node ID', 'error');
                    return;
                }
                
                try {
                    // Add node with explicit position if we have canvas position
                    const nodeData = { 
                        id, 
                        label: label || id
                    };
                    
                    // Add position data - use canvas position if available, otherwise let physics handle it
                    if (canvasPosition && canvasPosition.x !== undefined && canvasPosition.y !== undefined && 
                        Math.abs(canvasPosition.x) < 500 && Math.abs(canvasPosition.y) < 500) {
                        // Use canvas position if it's within reasonable bounds
                        nodeData.x = canvasPosition.x;
                        nodeData.y = canvasPosition.y;
                        console.log('Adding node at canvas position:', canvasPosition);
                    } else {
                        // Let physics determine position, but give a hint near other nodes
                        const existingNodes = window.graphApp.state.currentGraph.nodes;
                        if (existingNodes.length > 0) {
                            // Place near the center of existing nodes
                            const avgX = existingNodes.reduce((sum, n) => sum + (n.x || 0), 0) / existingNodes.length;
                            const avgY = existingNodes.reduce((sum, n) => sum + (n.y || 0), 0) / existingNodes.length;
                            nodeData.x = avgX + (Math.random() - 0.5) * 100;
                            nodeData.y = avgY + (Math.random() - 0.5) * 100;
                        }
                        // If no existing nodes, let physics place it (no x,y specified)
                        console.log('Adding node with physics positioning:', nodeData.x ? { x: nodeData.x, y: nodeData.y } : 'auto');
                    }
                    
                    console.log('Adding node with data:', nodeData);
                    window.graphApp.addNode(nodeData);
                    showStatus(`Node "${id}" added successfully`, 'success');
                    closeModal();
                    
                    // Force network to fit view to show new node
                    setTimeout(() => {
                        const network = window.graphApp.networks.editor;
                        if (network) {
                            network.fit({
                                animation: {
                                    duration: 500,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        }
                    }, 200);
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showEditNodeDialog(node) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Edit Node</h3>
                <input type="text" id="modal-node-id" class="modal-input" placeholder="Node ID" value="${node.id}" readonly style="background: #f5f5f5;" />
                <input type="text" id="modal-node-label" class="modal-input" placeholder="Node Label" value="${node.label || ''}" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="updateNode()">Update Node</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the label input
            setTimeout(() => {
                document.getElementById('modal-node-label').focus();
            }, 100);
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.updateNode;
            };
            
            window.updateNode = () => {
                const label = document.getElementById('modal-node-label').value.trim();
                
                try {
                    // Update the node label
                    const nodeIndex = window.graphApp.state.currentGraph.nodes.findIndex(n => n.id === node.id);
                    if (nodeIndex !== -1) {
                        window.graphApp.state.currentGraph.nodes[nodeIndex].label = label || node.id;
                        window.graphApp.dispatchEvent(new CustomEvent('graphUpdated', {
                            detail: { graph: window.graphApp.state.currentGraph }
                        }));
                        showStatus(`Node "${node.id}" updated successfully`, 'success');
                        closeModal();
                    }
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showEditEdgeDialog(edge) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Edit Edge</h3>
                <input type="text" id="modal-edge-source" class="modal-input" value="${edge.source}" readonly style="background: #f5f5f5;" />
                <input type="text" id="modal-edge-target" class="modal-input" value="${edge.target}" readonly style="background: #f5f5f5;" />
                <select id="modal-edge-type" class="modal-input">
                    <option value="+" ${edge.type === '+' ? 'selected' : ''}>Positive (+)</option>
                    <option value="-" ${edge.type === '-' ? 'selected' : ''}>Negative (-)</option>
                </select>
                <input type="number" id="modal-edge-weight" class="modal-input" placeholder="Weight" value="${edge.weight || 1}" step="0.1" min="0" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="updateEdge()">Update Edge</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.updateEdge;
            };
            
            window.updateEdge = () => {
                const type = document.getElementById('modal-edge-type').value;
                const weight = parseFloat(document.getElementById('modal-edge-weight').value) || 1;
                
                try {
                    // Update the edge
                    const edgeIndex = window.graphApp.state.currentGraph.edges.findIndex(e => 
                        e.source === edge.source && e.target === edge.target
                    );
                    if (edgeIndex !== -1) {
                        window.graphApp.state.currentGraph.edges[edgeIndex].type = type;
                        window.graphApp.state.currentGraph.edges[edgeIndex].weight = weight;
                        window.graphApp.dispatchEvent(new CustomEvent('graphUpdated', {
                            detail: { graph: window.graphApp.state.currentGraph }
                        }));
                        showStatus(`Edge "${edge.source} → ${edge.target}" updated successfully`, 'success');
                        closeModal();
                    }
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showAddEdgeDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            // Get existing node IDs for suggestions
            const nodeIds = window.graphApp.state.currentGraph.nodes.map(n => n.id);
            const nodeOptions = nodeIds.map(id => `<option value="${id}">${id}</option>`).join('');
            
            dialog.innerHTML = `
                <h3 class="modal-title">Add New Edge</h3>
                <select id="modal-edge-source" class="modal-input">
                    <option value="">Select Source Node</option>
                    ${nodeOptions}
                </select>
                <select id="modal-edge-target" class="modal-input">
                    <option value="">Select Target Node</option>
                    ${nodeOptions}
                </select>
                <select id="modal-edge-type" class="modal-input">
                    <option value="+">Positive (+)</option>
                    <option value="-">Negative (-)</option>
                </select>
                <input type="number" id="modal-edge-weight" class="modal-input" placeholder="Weight" value="1" step="0.1" min="0" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="createEdge()">Add Edge</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the first select
            setTimeout(() => {
                document.getElementById('modal-edge-source').focus();
            }, 100);
            
            // Handle enter key
            dialog.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createEdge();
                }
            });
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.createEdge;
            };
            
            window.createEdge = () => {
                const source = document.getElementById('modal-edge-source').value.trim();
                const target = document.getElementById('modal-edge-target').value.trim();
                const type = document.getElementById('modal-edge-type').value;
                const weight = parseFloat(document.getElementById('modal-edge-weight').value) || 1;
                
                if (!source) {
                    showStatus('Please select a source node', 'error');
                    return;
                }
                
                if (!target) {
                    showStatus('Please select a target node', 'error');
                    return;
                }
                
                if (source === target) {
                    showStatus('Source and target cannot be the same node', 'error');
                    return;
                }
                
                try {
                    const edgeData = { 
                        source, 
                        target, 
                        type,
                        weight 
                    };
                    
                    console.log('Adding edge with data:', edgeData);
                    window.graphApp.addEdge(edgeData);
                    showStatus(`Edge "${source} → ${target}" added successfully`, 'success');
                    closeModal();
                    
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }

        function initializeEventHandlers() {
            // File operations (still needed for compatibility)
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        window.graphApp.importGraph(event.target.result);
                        showStatus(`Graph loaded from "${file.name}"`, 'success');
                    } catch (error) {
                        showStatus(`Failed to load graph: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            });

            // File operations (now handled by menu, but keeping for compatibility)
            // These elements no longer exist in toolbar but IDs might be referenced elsewhere

            // Graph operations handled by menu now

            // Analysis operations
            document.getElementById('run-analysis').addEventListener('click', () => {
                window.graphApp.triggerAnalysis();
            });
            
            // Plugin selection change
            document.getElementById('plugin-select').addEventListener('change', (e) => {
                const selectedPlugin = e.target.value;
                if (selectedPlugin) {
                    console.log('Plugin selected:', selectedPlugin);
                    window.graphApp.setPlugin(selectedPlugin);
                }
            });

            // Listen for analysis events
            window.graphApp.addEventListener('analysisStarted', () => {
                document.getElementById('analysis-loading').classList.remove('hidden');
                document.getElementById('analysis-results').classList.add('hidden');
                document.getElementById('run-analysis').disabled = true;
            });

            window.graphApp.addEventListener('analysisCompleted', (e) => {
                document.getElementById('analysis-loading').classList.add('hidden');
                document.getElementById('analysis-results').classList.remove('hidden');
                document.getElementById('run-analysis').disabled = false;
                
                displayAnalysisResults(e.detail.results);
            });

            window.graphApp.addEventListener('analysisError', (e) => {
                document.getElementById('analysis-loading').classList.add('hidden');
                document.getElementById('run-analysis').disabled = false;
                showStatus(`Analysis failed: ${e.detail.error}`, 'error');
            });
        }

        // Test if Pyodide itself is the issue or something else
        let pyodideReadyPromise = null;
        
        async function testBasicPyodide() {
            try {
                console.log('🧪 Testing: Basic Pyodide loading...');
                const pyodide = await loadPyodide();
                console.log('✅ SUCCESS: Pyodide loaded');
                
                console.log('🧪 Testing: Basic Python execution...');
                pyodide.runPython('print("Hello from Python!")');
                console.log('✅ SUCCESS: Python execution works');
                
                console.log('🧪 Testing: Required packages loading...');
                await pyodide.loadPackage(['networkx', 'scipy', 'numpy']);
                console.log('✅ SUCCESS: NetworkX, SciPy, and NumPy loaded');
                
                console.log('🧪 Testing: Package imports...');
                pyodide.runPython(`
import networkx as nx
import scipy
import numpy as np
G = nx.Graph()
G.add_edge(1, 2)
print(f"NetworkX works: {G.number_of_nodes()} nodes")
print(f"SciPy version: {scipy.__version__}")
print(f"NumPy version: {np.__version__}")
                `);
                console.log('✅ SUCCESS: All packages import and work correctly');
                
                return pyodide;
            } catch (error) {
                console.error('❌ FAILED: Pyodide test failed at:', error.message);
                console.error('Full error:', error);
                throw error;
            }
        }
        
        // Start the basic test immediately
        pyodideReadyPromise = testBasicPyodide();
        
        async function initializeAnalysisSystem() {
            console.log('🔬 Analysis system: Waiting for Pyodide test results...');
            
            try {
                // Wait for Pyodide test to complete
                window.pyodide = await pyodideReadyPromise;
                console.log('🔬 Analysis system: Pyodide test passed, continuing with plugins...');
                
                // Get plugins directory from main process
                let pluginsDirectory;
                try {
                    console.log('🔬 Checking if require is available:', typeof window.require);
                    if (typeof window.require === 'function') {
                        pluginsDirectory = await window.require('electron').ipcRenderer.invoke('get-plugins-directory');
                        console.log('🔬 Using user plugins directory:', pluginsDirectory);
                    } else {
                        throw new Error('require function not available - nodeIntegration might be disabled');
                    }
                } catch (e) {
                    console.warn('Could not get user plugins directory, falling back to built-in:', e);
                    // Try multiple fallback paths for the plugins directory
                    const possiblePaths = [
                        '../py/plugins',
                        'py/plugins', 
                        './py/plugins',
                        '/home/carlos/graph-app/py/plugins'
                    ];
                    pluginsDirectory = possiblePaths[0]; // Default fallback
                    console.log('🔬 Using fallback plugins directory:', pluginsDirectory);
                    console.log('🔬 Will test directory existence in Python');
                }
                
                // Load plugin loader module
                console.log('🔬 Loading plugin loader...');
                const pluginLoaderResponse = await fetch('../py/plugin_loader.py');
                const pluginLoaderCode = await pluginLoaderResponse.text();
                window.pyodide.runPython(pluginLoaderCode);
                console.log('Plugin loader loaded');
                
                // Set plugins directory in Python
                console.log('🔬 Initializing plugin loader...');
                console.log('🔬 Plugin directory path:', pluginsDirectory);
                
                window.pyodide.runPython(`
# The plugin_loader code is already executed, so we can access its classes directly
import js
import os

# First check what the current working directory is
print(f"Current working directory: {os.getcwd()}")
print(f"Directory contents: {os.listdir('.')}")

# Test multiple possible plugin directory paths
possible_paths = [
    "../py/plugins",
    "py/plugins", 
    "./py/plugins",
    "graph-app/py/plugins",
    "src/../py/plugins"
]

print("Testing plugin directory paths:")
working_dir = None
for path in possible_paths:
    exists = os.path.exists(path)
    print(f"  {path}: exists = {exists}")
    if exists:
        try:
            contents = os.listdir(path)
            print(f"    Contents: {contents}")
            if working_dir is None:
                working_dir = path
        except Exception as e:
            print(f"    Error listing contents: {e}")

if working_dir:
    print(f"Using working directory: {working_dir}")
    _plugin_loader = PluginLoader(working_dir)
else:
    print("No valid plugin directory found, using fallback path anyway")
    _plugin_loader = PluginLoader("${pluginsDirectory.replace(/\\/g, '/')}")
    
print(f"Plugin loader initialized")
                `);
                
                // Discover plugins
                await discoverPlugins();
                
                // Check if any plugins were actually discovered
                if (window.graphApp.state.availablePlugins.size === 0) {
                    console.warn('No plugins discovered via traditional method, trying fetch approach...');
                    await initializePluginsViaFetch();
                } else {
                    console.log('Plugin-based analysis system initialized with', window.graphApp.state.availablePlugins.size, 'plugins');
                }
                
            } catch (error) {
                console.error('Failed to initialize plugin system, falling back to basic mode:', error);
                console.error('Full error details:', error.stack || error);
                showStatus('Plugin system failed to load, using fallback analysis', 'warning');
                
                // Try alternative plugin loading approach
                await initializePluginsViaFetch();
            }
        }
        
        async function discoverPlugins() {
            try {
                // Run plugin discovery
                const result = window.pyodide.runPython(`discover_plugins_js()`);
                const discovery = JSON.parse(result);
                
                if (!discovery.success) {
                    throw new Error(discovery.error);
                }
                
                console.log('Discovered plugins:', discovery.plugins);
                
                // Register plugins with shared state
                window.graphApp.state.availablePlugins.clear();
                
                for (const plugin of discovery.plugins) {
                    window.graphApp.state.availablePlugins.set(plugin.id, {
                        info: plugin,
                        analyze: async (graph, params) => {
                            return await executePlugin(plugin.id, graph, params);
                        }
                    });
                }
                
                // Update plugin dropdown
                updatePluginDropdown(discovery.plugins);
                
                // Show any plugin loading errors
                if (Object.keys(discovery.errors).length > 0) {
                    console.warn('Plugin loading errors:', discovery.errors);
                    for (const [plugin, error] of Object.entries(discovery.errors)) {
                        showStatus(`Plugin ${plugin} failed to load: ${error}`, 'warning');
                    }
                }
                
            } catch (error) {
                console.error('Plugin discovery failed:', error);
                console.error('Full error details:', error.stack || error);
                throw error;
            }
        }
        
        async function executePluginViaFetch(pluginId, graph, parameters) {
            try {
                console.log('🔌 Executing plugin via fetch:', pluginId);
                
                // Fetch the analysis.py file for this plugin
                const analysisResponse = await fetch(`../py/plugins/${pluginId}/analysis.py`);
                if (!analysisResponse.ok) {
                    throw new Error(`Could not load analysis code for ${pluginId}`);
                }
                
                const analysisCode = await analysisResponse.text();
                console.log('✅ Loaded analysis code for', pluginId);
                
                // Ensure required packages are loaded
                if (!window.packagesLoaded) {
                    console.log('Loading required packages for plugin execution...');
                    await window.pyodide.loadPackage(['networkx', 'scipy', 'numpy']);
                    window.packagesLoaded = true;
                    console.log('✅ Loaded NetworkX, SciPy, and NumPy');
                }
                
                // Execute the plugin analysis in Pyodide
                const nodesJson = JSON.stringify(graph.nodes);
                const edgesJson = JSON.stringify(graph.edges);
                const paramsJson = JSON.stringify(parameters || {});
                
                console.log('📊 Graph data for plugin:');
                console.log('  Nodes:', graph.nodes.length, 'items');
                console.log('  Edges:', graph.edges.length, 'items');
                if (graph.nodes.length > 0) console.log('  First node:', graph.nodes[0]);
                if (graph.edges.length > 0) console.log('  First edge:', graph.edges[0]);
                
                // Basic validation
                if (graph.nodes.length === 0) {
                    throw new Error('No nodes in graph - cannot run analysis');
                }
                if (graph.nodes.length < 2) {
                    console.warn('Warning: Graph has only 1 node, some analyses may not work properly');
                }
                
                // Encode the analysis code as base64 to avoid quote/escape issues
                // Use proper UTF-8 to base64 encoding
                function utf8ToBase64(str) {
                    return btoa(unescape(encodeURIComponent(str)));
                }
                const analysisCodeB64 = utf8ToBase64(analysisCode);
                
                const result = window.pyodide.runPython(`
import json
import base64

def run_plugin_analysis():
    # Load the analysis code into Pyodide using base64 decoding
    try:
        analysis_code = base64.b64decode("${analysisCodeB64}").decode('utf-8')
        exec(analysis_code, globals())
        print("✅ Analysis code loaded successfully")
    except Exception as e:
        print(f"❌ Failed to load analysis code: {e}")
        return json.dumps({"error": f"Failed to load analysis code: {e}", "summary": f"Code loading failed: {e}"})

    # Parse the input data  
    try:
        nodes = json.loads('''${nodesJson}''')
        edges = json.loads('''${edgesJson}''')
        params = json.loads('''${paramsJson}''')
        print(f"✅ Parsed {len(nodes)} nodes and {len(edges)} edges")
    except Exception as e:
        print(f"❌ JSON parsing failed: {e}")
        return json.dumps({"error": f"JSON parsing failed: {e}", "summary": f"Data parsing failed: {e}"})

    # Execute the analysis
    try:
        analysis_result = analyze_graph(nodes, edges, params)
        print(f"✅ Plugin ${pluginId} executed successfully")
        
        # Custom JSON encoder to handle frozensets and other non-serializable types
        class CustomJSONEncoder(json.JSONEncoder):
            def default(self, obj):
                if isinstance(obj, frozenset):
                    return list(obj)
                if isinstance(obj, set):
                    return list(obj)
                try:
                    return super().default(obj)
                except TypeError:
                    return str(obj)
        
        return json.dumps(analysis_result, cls=CustomJSONEncoder)
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print(f"❌ Plugin ${pluginId} execution failed: {e}")
        print("Full traceback:")
        print(error_details)
        return json.dumps({"error": str(e), "summary": f"Plugin execution failed: {e}", "traceback": error_details})

# Execute the function and return the result
run_plugin_analysis()
                `);
                
                console.log('🐍 Python result:', result);
                
                if (!result || result === 'undefined') {
                    throw new Error('Plugin execution returned no result');
                }
                
                const response = JSON.parse(result);
                
                if (response.error) {
                    throw new Error(response.error);
                }
                
                console.log('🎉 Plugin execution successful:', pluginId);
                return response;
                
            } catch (error) {
                console.error(`Plugin ${pluginId} execution failed:`, error);
                return {
                    summary: `Plugin ${pluginId} execution failed: ${error.message}`,
                    error: error.message
                };
            }
        }

        async function executePlugin(pluginId, graph, parameters) {
            try {
                // Ensure required packages are loaded before plugin execution
                if (!window.packagesLoaded) {
                    console.log('Loading required packages for plugin execution...');
                    await window.pyodide.loadPackage(['networkx', 'scipy', 'numpy']);
                    window.packagesLoaded = true;
                    console.log('✅ Loaded NetworkX, SciPy, and NumPy');
                }
                
                const nodesJson = JSON.stringify(graph.nodes);
                const edgesJson = JSON.stringify(graph.edges);
                const paramsJson = JSON.stringify(parameters || {});
                
                const result = window.pyodide.runPython(`
execute_plugin_js('${pluginId}', '''${nodesJson}''', '''${edgesJson}''', '''${paramsJson}''')
                `);
                
                const response = JSON.parse(result);
                
                if (!response.success) {
                    throw new Error(response.error);
                }
                
                return response.results;
                
            } catch (error) {
                console.error(`Plugin ${pluginId} execution failed:`, error);
                throw error;
            }
        }
        
        function updatePluginDropdown(plugins) {
            const select = document.getElementById('plugin-select');
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add discovered plugins
            for (const plugin of plugins) {
                const option = document.createElement('option');
                option.value = plugin.id;
                option.textContent = plugin.name;
                option.title = plugin.description;
                select.appendChild(option);
            }
            
            // If no plugins found, add placeholder
            if (plugins.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No plugins available';
                option.disabled = true;
                select.appendChild(option);
            }
            
            // Select first plugin if available
            if (plugins.length > 0) {
                window.graphApp.setPlugin(plugins[0].id);
            }
        }
        
        async function initializePluginsViaFetch() {
            console.log('🔄 Trying alternative plugin loading via fetch...');
            
            try {
                // Try to load plugins directly by fetching their __init__.py files
                const pluginNames = [
                    'node-centrality',
                    'community-detection', 
                    'path-analysis',
                    'node-importance',
                    'edge-analysis',
                    'basic-statistics',
                    'causal-paths'
                ];
                
                const plugins = [];
                
                for (const pluginName of pluginNames) {
                    try {
                        console.log(`🔍 Fetching plugin: ${pluginName}`);
                        const initResponse = await fetch(`../py/plugins/${pluginName}/__init__.py`);
                        console.log(`📡 Response for ${pluginName}:`, initResponse.status, initResponse.statusText);
                        if (initResponse.ok) {
                            const initCode = await initResponse.text();
                            
                            // Extract ANALYSIS_INFO from the plugin
                            const analysisMatch = initCode.match(/ANALYSIS_INFO\s*=\s*({[\s\S]*?})/);
                            if (analysisMatch) {
                                try {
                                    // Try to parse the ANALYSIS_INFO as Python dict -> JSON
                                    let analysisInfo = analysisMatch[1];
                                    
                                    // Convert Python dict syntax to JSON
                                    analysisInfo = analysisInfo
                                        .replace(/'/g, '"')  // Single quotes to double quotes
                                        .replace(/True/g, 'true')
                                        .replace(/False/g, 'false')
                                        .replace(/None/g, 'null');
                                    
                                    const plugin = JSON.parse(analysisInfo);
                                    plugins.push(plugin);
                                    console.log('✅ Loaded plugin via fetch:', plugin.name);
                                } catch (parseError) {
                                    // Fallback to simple plugin info
                                    const plugin = {
                                        id: pluginName,
                                        name: `${pluginName.charAt(0).toUpperCase() + pluginName.slice(1).replace(/-/g, ' ')} Analysis`,
                                        description: `${pluginName} analysis plugin`,
                                        version: '1.0.0'
                                    };
                                    plugins.push(plugin);
                                    console.log('📝 Loaded plugin with basic info:', plugin.name);
                                }
                            }
                        }
                    } catch (e) {
                        console.warn(`Could not load plugin ${pluginName}:`, e);
                    }
                }
                
                if (plugins.length > 0) {
                    console.log('Successfully loaded', plugins.length, 'plugins via fetch');
                    updatePluginDropdown(plugins);
                    
                    // Register plugin handlers with fetch-based execution
                    for (const plugin of plugins) {
                        window.graphApp.state.availablePlugins.set(plugin.id, {
                            info: plugin,
                            analyze: async (graph, params) => {
                                return await executePluginViaFetch(plugin.id, graph, params);
                            }
                        });
                    }
                    return;
                }
            } catch (error) {
                console.error('Alternative plugin loading failed:', error);
            }
            
            // If all else fails, use fallback
            await initializeFallbackAnalysis();
        }

        async function initializeFallbackAnalysis() {
            console.log('Initializing fallback analysis system...');
            
            // Fallback to basic JavaScript analysis if Python fails
            window.graphApp.state.availablePlugins.set('basic-analysis', {
                info: {
                    id: 'basic-analysis',
                    name: 'Basic Analysis (Fallback)',
                    description: 'Simple JavaScript-based analysis when Python plugins fail'
                },
                analyze: async (graph, params) => {
                    if (graph.nodes.length === 0) {
                        throw new Error('No nodes in graph to analyze');
                    }
                    
                    // Basic influence scores
                    const influenceScores = {};
                    graph.nodes.forEach(node => {
                        let score = 0;
                        graph.edges.forEach(edge => {
                            if (edge.target === node.id) {
                                const weight = edge.type === '-' ? -edge.weight : edge.weight;
                                score += weight;
                            }
                        });
                        influenceScores[node.label || node.id] = score;
                    });
                    
                    return {
                        metadata: {
                            analysis_id: 'basic-analysis',
                            analysis_name: 'Basic Analysis (Fallback)',
                            timestamp: new Date().toISOString()
                        },
                        results: {
                            primary: {
                                influence_scores: influenceScores
                            }
                        },
                        summary: `Fallback analysis complete. Found ${Object.keys(influenceScores).length} nodes with influence scores.`
                    };
                }
            });
            
            // Update dropdown for fallback
            updatePluginDropdown([{
                id: 'basic-analysis',
                name: 'Basic Analysis (Fallback)', 
                description: 'Simple JavaScript-based analysis when Python plugins fail'
            }]);
            
            console.log('Fallback analysis system initialized');
        }
        
        function formatAnalysisSummary(results) {
            const lines = [];
            
            if (results.influence_scores) {
                const scores = Object.entries(results.influence_scores);
                if (scores.length > 0) {
                    const topNode = scores.reduce((a, b) => a[1] > b[1] ? a : b);
                    lines.push(`Highest influence: ${topNode[0]} (${topNode[1]})`);
                }
            }
            
            if (results.positive_paths && results.positive_paths.length > 0) {
                lines.push(`Found ${results.positive_paths.length} positive path(s)`);
            }
            
            if (results.negative_paths && results.negative_paths.length > 0) {
                lines.push(`Found ${results.negative_paths.length} negative path(s)`);
            }
            
            return lines.length > 0 ? lines.join('. ') + '.' : 'Analysis completed successfully.';
        }

        function displayAnalysisResults(results) {
            const container = document.getElementById('results-content');
            
            let html = `<div style="margin-bottom: 15px;"><strong>Summary:</strong> ${results.summary}</div>`;
            
            // Show metadata if available
            if (results.metadata) {
                const meta = results.metadata;
                html += `<div style="margin-bottom: 15px; font-size: 12px; color: #666;">
                    <strong>Analysis:</strong> ${meta.analysis_name} | 
                    <strong>Nodes:</strong> ${meta.graph_stats?.nodes || 0} | 
                    <strong>Edges:</strong> ${meta.graph_stats?.edges || 0}`;
                
                if (meta.execution_time_ms) {
                    html += ` | <strong>Time:</strong> ${meta.execution_time_ms}ms`;
                }
                html += `</div>`;
            }
            
            if (results.results && results.results.primary) {
                const primary = results.results.primary;
                
                // Display influence scores
                if (primary.influence_scores && Object.keys(primary.influence_scores).length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Influence Scores:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    const sortedScores = Object.entries(primary.influence_scores)
                        .sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
                    
                    sortedScores.forEach(([node, score]) => {
                        const color = score > 0 ? 'green' : score < 0 ? 'red' : 'gray';
                        html += `<div><span style="color: ${color};">${node}: ${score}</span></div>`;
                    });
                    html += `</div></div>`;
                }
                
                // Display positive paths
                if (primary.positive_paths && primary.positive_paths.length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Positive Paths:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    primary.positive_paths.forEach(path => {
                        html += `<div>${path.join(' → ')}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // Display negative paths
                if (primary.negative_paths && primary.negative_paths.length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Negative Paths:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    primary.negative_paths.forEach(path => {
                        html += `<div>${path.join(' → ')}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // If no meaningful results, show raw data
                if (!primary.influence_scores && !primary.positive_paths && !primary.negative_paths) {
                    html += `<div><strong>Raw Results:</strong>
                        <pre style="font-size: 12px;">${JSON.stringify(primary, null, 2)}</pre></div>`;
                }
            }
            
            container.innerHTML = html;
        }

        function showStatus(message, type = 'info') {
            const container = document.getElementById('status-container');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
            
            container.appendChild(statusDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const editorNetwork = window.graphApp.networks.editor;
            const analysisNetwork = window.graphApp.networks.analysis;
            
            if (editorNetwork) {
                editorNetwork.fit();
            }
            if (analysisNetwork) {
                analysisNetwork.fit();
            }
        });
    </script>
</body>
</html>