<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Causal Graph Tool</title>
    
    <!-- External Dependencies -->
    <script src="https://unpkg.com/vis-network@latest/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdn.jsdelivr.net/pyodide/v0.26.3/full/pyodide.js"></script>
    
    <!-- Application Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
        }

        /* Top Toolbar */
        .toolbar {
            height: 60px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .toolbar h1 {
            font-size: 18px;
            margin-right: 30px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-section:not(:last-child) {
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #34495e;
        }

        .toolbar button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .toolbar button:hover {
            background: #2980b9;
        }

        .toolbar button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .toolbar select {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
            font-size: 14px;
        }

        .toolbar input[type="file"] {
            display: none;
        }

        .toolbar label {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .toolbar label:hover {
            background: #229954;
        }

        .toolbar-input {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            min-width: 80px;
        }

        .toolbar-input.small {
            min-width: 60px;
            max-width: 80px;
        }

        .toolbar-select {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            min-width: 50px;
        }

        .toolbar button.danger {
            background: #e74c3c;
        }

        .toolbar button.danger:hover {
            background: #c0392b;
        }

        /* Main Content Area */
        .main-content {
            height: calc(100vh - 60px);
            display: flex;
        }

        /* Split Pane Container */
        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Editor Pane */
        .editor-pane {
            flex: 1;
            min-width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            position: relative;  /* Ensure controls stay within pane */
        }

        .editor-header {
            padding: 15px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            font-weight: 600;
            color: #2c3e50;
        }


        .vis-network {
            flex: 1;
            width: 100%;
            background: white;
        }

        /* Resizable Splitter */
        .splitter {
            width: 5px;
            background: #bdc3c7;
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
        }

        .splitter:hover {
            background: #95a5a6;
        }

        .splitter::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 30px;
            background: #7f8c8d;
            border-radius: 2px;
        }

        /* Analysis Pane */
        .analysis-pane {
            flex: 1;
            min-width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .analysis-header {
            padding: 15px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .analysis-header h2 {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .plugin-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .plugin-selector select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .run-analysis-btn {
            padding: 8px 16px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .run-analysis-btn:hover {
            background: #229954;
        }

        .run-analysis-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        /* Analysis Results */
        .analysis-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .analysis-results {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .analysis-results h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .analysis-results pre {
            background: white;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Status Messages */
        .status-message {
            padding: 10px 15px;
            margin: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .split-container {
                flex-direction: column;
            }
            
            .splitter {
                width: 100%;
                height: 5px;
                cursor: row-resize;
            }
            
            .editor-pane,
            .analysis-pane {
                min-width: unset;
                min-height: 300px;
            }
            
            .toolbar {
                flex-wrap: wrap;
                height: auto;
                min-height: 60px;
            }
            
            .toolbar-section {
                margin-right: 15px;
                padding-right: 15px;
            }
        }


        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10000;
            min-width: 150px;
            padding: 4px 0;
            font-size: 14px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e74c3c;
        }

        .context-menu-item.danger:hover {
            background: #fdf2f2;
        }

        .context-menu-separator {
            height: 1px;
            background: #eee;
            margin: 4px 0;
        }

        /* Modal dialog styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .modal-dialog {
            background: white;
            border-radius: 6px;
            padding: 20px;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .modal-title {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .modal-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-button.primary {
            background: #3498db;
            color: white;
        }

        .modal-button.primary:hover {
            background: #2980b9;
        }

        .modal-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .modal-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Hide elements when not needed */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Top Toolbar -->
    <div class="toolbar">
        <h1>Causal Graph Tool</h1>
        
        
        <div class="toolbar-section">
            <span>Nodes: <span id="node-count">0</span></span>
            <span>Edges: <span id="edge-count">0</span></span>
        </div>
        
        <div class="toolbar-section">
            <span id="mode-indicator">Right-click canvas to add nodes</span>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="split-container">
            <!-- Editor Pane -->
            <div class="editor-pane">
                <div class="editor-header">
                    <h2>Graph Editor</h2>
                </div>
                
                <!-- Graph Network (takes full space) -->
                <div id="editor-network" class="vis-network"></div>
            </div>

            <!-- Resizable Splitter -->
            <div class="splitter" id="splitter"></div>

            <!-- Analysis Pane -->
            <div class="analysis-pane">
                <div class="analysis-header">
                    <h2>Analysis</h2>
                    <div class="plugin-selector">
                        <select id="plugin-select">
                            <option value="causal-paths">Causal Path Analysis</option>
                            <option value="centrality" disabled>Centrality (Coming Soon)</option>
                            <option value="community" disabled>Community Detection (Coming Soon)</option>
                        </select>
                        <button id="run-analysis" class="run-analysis-btn">Analyze</button>
                    </div>
                </div>
                
                <!-- Analysis Content -->
                <div class="analysis-content">
                    <div id="analysis-placeholder" class="analysis-results">
                        <h3>Ready to Analyze</h3>
                        <p>Create a graph in the editor and click "Analyze" to see results.</p>
                        <p>Analysis will run automatically as you make changes to the graph.</p>
                    </div>
                    
                    <div id="analysis-loading" class="loading hidden">
                        Analyzing graph...
                    </div>
                    
                    <div id="analysis-results" class="analysis-results hidden">
                        <h3>Analysis Results</h3>
                        <div id="results-content"></div>
                    </div>
                    
                    <!-- Graph Visualization for Analysis -->
                    <div id="analysis-visualization" class="graph-container hidden" data-container-type="analysis" style="height: 300px; margin-top: 20px;">
                        <div id="analysis-network" class="vis-network"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Messages Container -->
    <div id="status-container"></div>

    <!-- Hidden file input for menu operations -->
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <!-- Include Shared State -->
    <script src="shared-state.js"></script>

    <!-- Main Application Script -->
    <script>
        // Initialize the unified interface
        document.addEventListener('DOMContentLoaded', function() {
            initializeUnifiedInterface();
            
            // Set up IPC listeners for menu commands
            if (window.require) {
                try {
                    const { ipcRenderer } = window.require('electron');
                    console.log('IPC Renderer available, setting up menu listeners...');
                    
                    ipcRenderer.on('menu-new-graph', () => {
                        console.log('Menu: New Graph clicked');
                        if (confirm('Create a new graph? This will clear the current graph.')) {
                            window.graphApp.updateGraph({ nodes: [], edges: [] });
                            showStatus('New graph created', 'info');
                        }
                    });
                    
                    ipcRenderer.on('menu-load-graph-content', (event, fileContent, fileName) => {
                        console.log('Menu: Load Graph content received');
                        try {
                            window.graphApp.importGraph(fileContent);
                            showStatus(`Graph loaded from "${fileName}"`, 'success');
                        } catch (error) {
                            showStatus(`Failed to load graph: ${error.message}`, 'error');
                        }
                    });
                    
                    ipcRenderer.on('menu-save-graph', () => {
                        console.log('Menu: Save Graph clicked');
                        saveGraphFile();
                    });
                    
                    ipcRenderer.on('menu-fit-graph', () => {
                        console.log('Menu: Fit Graph clicked');
                        const network = window.graphApp.networks.editor;
                        if (network) {
                            network.fit();
                        }
                    });
                    
                } catch (error) {
                    console.error('Failed to set up IPC listeners:', error);
                }
            } else {
                console.warn('window.require not available, menu shortcuts will not work');
            }
        });

        async function initializeUnifiedInterface() {
            console.log('Initializing Causal Graph Tool...');
            
            // Initialize shared state
            const app = window.graphApp;
            
            // Initialize networks
            initializeEditorNetwork();
            initializeSplitter();
            initializeEventHandlers();
            
            // Initialize analysis system (placeholder for now)
            await initializeAnalysisSystem();
            
            console.log('Application initialized successfully');
        }

        function initializeEditorNetwork() {
            const container = document.getElementById('editor-network');
            
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: { color: '#2c3e50', size: 14 },
                    borderWidth: 2,
                    shadow: true
                },
                edges: {
                    arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                    smooth: { type: 'curvedCW', roundness: 0.1 },
                    font: { color: '#34495e', size: 12, align: 'middle' },
                    shadow: true
                },
                physics: {
                    enabled: true,
                    stabilization: { 
                        enabled: true,
                        iterations: 500,
                        updateInterval: 25
                    },
                    barnesHut: {
                        gravitationalConstant: -2000,
                        centralGravity: 0.3,
                        springLength: 95,
                        springConstant: 0.04,
                        damping: 0.09
                    }
                },
                interaction: {
                    hover: true,
                    selectConnectedEdges: false
                },
                // Force vis-network to use full container size
                autoResize: true,
                width: '100%',
                height: '100%'
            };

            const editorNetwork = new vis.Network(container, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
            
            // Force resize to container dimensions
            function resizeNetwork() {
                const rect = container.getBoundingClientRect();
                editorNetwork.setSize(rect.width + 'px', rect.height + 'px');
                editorNetwork.fit();
            }
            
            // Initial resize
            setTimeout(resizeNetwork, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeNetwork);
            
            // Register with shared state
            window.graphApp.registerNetwork('editor', editorNetwork);
            
            // Listen for graph updates
            window.graphApp.addEventListener('graphUpdated', (e) => {
                updateNetworkData(editorNetwork, e.detail.graph);
                updateStats(e.detail.graph);
            });
            
            // Add context menu support
            setupContextMenus(editorNetwork);
        }

        function updateNetworkData(network, graphData) {
            const nodes = new vis.DataSet(graphData.nodes.map((node, index) => ({
                id: node.id,
                label: node.label || node.id,
                group: node.group || 'default',
                title: `${node.label || node.id}\nType: ${node.type || 'N/A'}\nGroup: ${node.group || 'default'}`,
                // Ensure nodes have positions - use provided or generate reasonable defaults
                x: node.x !== undefined ? node.x : (index * 150) - (graphData.nodes.length * 75),
                y: node.y !== undefined ? node.y : Math.sin(index * 0.8) * 100
            })));

            const edges = new vis.DataSet(graphData.edges.map(edge => ({
                id: `${edge.source}-${edge.target}`,
                from: edge.source,
                to: edge.target,
                label: edge.type + (edge.weight !== 1 ? ` (${edge.weight})` : ''),
                color: edge.type === '+' ? '#27ae60' : '#e74c3c',
                width: Math.abs(edge.weight) * 2,
                title: `${edge.source} → ${edge.target}\nType: ${edge.type}\nWeight: ${edge.weight}`
            })));

            network.setData({ nodes, edges });
            
            // Ensure nodes are visible by fitting the view
            if (graphData.nodes.length > 0) {
                setTimeout(() => {
                    network.fit({
                        animation: {
                            duration: 1000,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                }, 300);
            }
        }

        function updateStats(graphData) {
            document.getElementById('node-count').textContent = graphData.nodes.length;
            document.getElementById('edge-count').textContent = graphData.edges.length;
            
            // Debug: Log node positions
            if (graphData.nodes.length > 0) {
                console.log('Current nodes:', graphData.nodes);
                
                // Auto-fit if we have nodes but they might be invisible
                setTimeout(() => {
                    const network = window.graphApp.networks.editor;
                    if (network) {
                        network.fit();
                    }
                }, 200);
            }
        }

        function setupContextMenus(network) {
            let contextMenu = null;
            let contextPosition = { x: 0, y: 0 };
            let contextNodeId = null;
            let contextEdgeId = null;
            
            // Disable default context menu
            const container = document.getElementById('editor-network');
            console.log('Setting up context menu on container:', container);
            
            // Ensure network is fully initialized before setting up events
            network.once('stabilizationIterationsDone', () => {
                console.log('Network stabilized, context menus are ready');
            });
            
            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Context menu triggered at:', e.clientX, e.clientY);
                
                contextPosition = { x: e.clientX, y: e.clientY };
                
                // Get canvas position relative to the container
                const containerRect = container.getBoundingClientRect();
                const canvasPosition = { 
                    x: e.clientX - containerRect.left, 
                    y: e.clientY - containerRect.top 
                };
                console.log('Canvas position:', canvasPosition);
                
                // Use vis-network API to get the clicked position
                const domPointer = { x: e.offsetX, y: e.offsetY };
                const networkPointer = network.DOMtoCanvas(domPointer);
                
                // Check what was clicked using vis-network methods
                const nodeId = network.getNodeAt(domPointer);
                const edgeId = network.getEdgeAt(domPointer);
                console.log('Clicked on:', { nodeId, edgeId, domPointer, networkPointer });
                
                if (nodeId) {
                    showNodeContextMenu(e.clientX, e.clientY, nodeId);
                } else if (edgeId) {
                    showEdgeContextMenu(e.clientX, e.clientY, edgeId);
                } else {
                    // Use network coordinates for adding nodes
                    showCanvasContextMenu(e.clientX, e.clientY, networkPointer);
                }
            });
            
            // Also try adding the event listener to the canvas element directly
            network.on('oncontext', (params) => {
                console.log('vis-network oncontext event:', params);
                if (params.event && params.event.preventDefault) {
                    params.event.preventDefault();
                    
                    const canvasPosition = { x: params.pointer.canvas.x, y: params.pointer.canvas.y };
                    const domPosition = { x: params.pointer.DOM.x, y: params.pointer.DOM.y };
                    
                    if (params.nodes && params.nodes.length > 0) {
                        showNodeContextMenu(domPosition.x, domPosition.y, params.nodes[0]);
                    } else if (params.edges && params.edges.length > 0) {
                        showEdgeContextMenu(domPosition.x, domPosition.y, params.edges[0]);
                    } else {
                        showCanvasContextMenu(domPosition.x, domPosition.y, canvasPosition);
                    }
                }
            });
            
            // Close context menu on click elsewhere
            document.addEventListener('click', () => {
                closeContextMenu();
            });
            
            // Close context menu on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeContextMenu();
                }
            });
            
            function closeContextMenu() {
                if (contextMenu) {
                    document.body.removeChild(contextMenu);
                    contextMenu = null;
                }
            }
            
            function showCanvasContextMenu(x, y, canvasPosition) {
                closeContextMenu();
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const addNodeItem = document.createElement('button');
                addNodeItem.className = 'context-menu-item';
                addNodeItem.innerHTML = '➕ Add Node';
                addNodeItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showAddNodeDialog(canvasPosition);
                };
                
                contextMenu.appendChild(addNodeItem);
                document.body.appendChild(contextMenu);
            }
            
            function showNodeContextMenu(x, y, nodeId) {
                closeContextMenu();
                
                const node = window.graphApp.state.currentGraph.nodes.find(n => n.id === nodeId);
                if (!node) return;
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const editItem = document.createElement('button');
                editItem.className = 'context-menu-item';
                editItem.innerHTML = '✏️ Edit Node';
                editItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showEditNodeDialog(node);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const deleteItem = document.createElement('button');
                deleteItem.className = 'context-menu-item danger';
                deleteItem.innerHTML = '🗑️ Delete Node';
                deleteItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (confirm(`Delete node "${node.label || node.id}"?`)) {
                        window.graphApp.deleteNode(nodeId);
                        showStatus(`Node "${node.label || node.id}" deleted`, 'success');
                    }
                };
                
                contextMenu.appendChild(editItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(deleteItem);
                document.body.appendChild(contextMenu);
            }
            
            function showEdgeContextMenu(x, y, edgeId) {
                closeContextMenu();
                console.log('Looking for edge with ID:', edgeId);
                console.log('Available edges:', window.graphApp.state.currentGraph.edges);
                
                const edge = window.graphApp.state.currentGraph.edges.find(e => 
                    `${e.source}-${e.target}` === edgeId
                );
                console.log('Found edge:', edge);
                if (!edge) {
                    console.warn('Edge not found for ID:', edgeId);
                    return;
                }
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const editItem = document.createElement('button');
                editItem.className = 'context-menu-item';
                editItem.innerHTML = '✏️ Edit Edge';
                editItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showEditEdgeDialog(edge);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const deleteItem = document.createElement('button');
                deleteItem.className = 'context-menu-item danger';
                deleteItem.innerHTML = '🗑️ Delete Edge';
                deleteItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (confirm(`Delete edge "${edge.source} → ${edge.target}"?`)) {
                        window.graphApp.deleteEdge(edge.source, edge.target);
                        showStatus(`Edge "${edge.source} → ${edge.target}" deleted`, 'success');
                    }
                };
                
                contextMenu.appendChild(editItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(deleteItem);
                document.body.appendChild(contextMenu);
            }
        }

        function initializeSplitter() {
            const splitter = document.getElementById('splitter');
            const container = document.querySelector('.split-container');
            const editorPane = document.querySelector('.editor-pane');
            const analysisPane = document.querySelector('.analysis-pane');
            
            let isResizing = false;
            
            splitter.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const containerWidth = containerRect.width;
                
                // Calculate percentages
                const leftPercent = (x / containerWidth) * 100;
                const rightPercent = 100 - leftPercent;
                
                // Enforce minimum widths (30% each)
                if (leftPercent >= 30 && rightPercent >= 30) {
                    editorPane.style.flex = `0 0 ${leftPercent}%`;
                    analysisPane.style.flex = `0 0 ${rightPercent}%`;
                    
                    // Trigger network resize and control adaptation
                    setTimeout(() => {
                        const editorNetwork = window.graphApp.networks.editor;
                        const analysisNetwork = window.graphApp.networks.analysis;
                        
                        if (editorNetwork) {
                            const editorContainer = document.getElementById('editor-network');
                            const rect = editorContainer.getBoundingClientRect();
                            editorNetwork.setSize(rect.width + 'px', rect.height + 'px');
                            editorNetwork.fit();
                        }
                        if (analysisNetwork) {
                            analysisNetwork.fit();
                        }
                    }, 50);
                }
            }
            
            function stopResize() {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }

        function saveGraphFile() {
            try {
                const jsonData = window.graphApp.exportGraph();
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'graph.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('Graph saved successfully', 'success');
            } catch (error) {
                showStatus(`Failed to save graph: ${error.message}`, 'error');
            }
        }

        function showAddNodeDialog(canvasPosition) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Add New Node</h3>
                <input type="text" id="modal-node-id" class="modal-input" placeholder="Node ID (required)" />
                <input type="text" id="modal-node-label" class="modal-input" placeholder="Node Label (optional)" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="createNode()">Add Node</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the first input
            setTimeout(() => {
                document.getElementById('modal-node-id').focus();
            }, 100);
            
            // Handle enter key
            dialog.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createNode();
                }
            });
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.createNode;
            };
            
            window.createNode = () => {
                const id = document.getElementById('modal-node-id').value.trim();
                const label = document.getElementById('modal-node-label').value.trim();
                
                if (!id) {
                    showStatus('Please enter a node ID', 'error');
                    return;
                }
                
                try {
                    // Add node with explicit position if we have canvas position
                    const nodeData = { 
                        id, 
                        label: label || id
                    };
                    
                    // Add position data if available from canvas click
                    if (canvasPosition && canvasPosition.x !== undefined && canvasPosition.y !== undefined) {
                        nodeData.x = canvasPosition.x;
                        nodeData.y = canvasPosition.y;
                        console.log('Adding node at canvas position:', canvasPosition);
                    } else {
                        // Generate a position near the center but not exactly at 0,0
                        const existingNodes = window.graphApp.state.currentGraph.nodes.length;
                        const angle = (existingNodes * 137.5) * (Math.PI / 180); // Golden angle for good distribution
                        const radius = 50 + (existingNodes * 20);
                        nodeData.x = Math.cos(angle) * radius;
                        nodeData.y = Math.sin(angle) * radius;
                        console.log('Adding node at generated position:', { x: nodeData.x, y: nodeData.y });
                    }
                    
                    console.log('Adding node with data:', nodeData);
                    window.graphApp.addNode(nodeData);
                    showStatus(`Node "${id}" added successfully`, 'success');
                    closeModal();
                    
                    // Force network to fit view to show new node
                    setTimeout(() => {
                        const network = window.graphApp.networks.editor;
                        if (network) {
                            network.fit({
                                animation: {
                                    duration: 500,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        }
                    }, 200);
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showEditNodeDialog(node) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Edit Node</h3>
                <input type="text" id="modal-node-id" class="modal-input" placeholder="Node ID" value="${node.id}" readonly style="background: #f5f5f5;" />
                <input type="text" id="modal-node-label" class="modal-input" placeholder="Node Label" value="${node.label || ''}" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="updateNode()">Update Node</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the label input
            setTimeout(() => {
                document.getElementById('modal-node-label').focus();
            }, 100);
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.updateNode;
            };
            
            window.updateNode = () => {
                const label = document.getElementById('modal-node-label').value.trim();
                
                try {
                    // Update the node label
                    const nodeIndex = window.graphApp.state.currentGraph.nodes.findIndex(n => n.id === node.id);
                    if (nodeIndex !== -1) {
                        window.graphApp.state.currentGraph.nodes[nodeIndex].label = label || node.id;
                        window.graphApp.dispatchEvent(new CustomEvent('graphUpdated', {
                            detail: { graph: window.graphApp.state.currentGraph }
                        }));
                        showStatus(`Node "${node.id}" updated successfully`, 'success');
                        closeModal();
                    }
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showEditEdgeDialog(edge) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Edit Edge</h3>
                <input type="text" id="modal-edge-source" class="modal-input" value="${edge.source}" readonly style="background: #f5f5f5;" />
                <input type="text" id="modal-edge-target" class="modal-input" value="${edge.target}" readonly style="background: #f5f5f5;" />
                <select id="modal-edge-type" class="modal-input">
                    <option value="+" ${edge.type === '+' ? 'selected' : ''}>Positive (+)</option>
                    <option value="-" ${edge.type === '-' ? 'selected' : ''}>Negative (-)</option>
                </select>
                <input type="number" id="modal-edge-weight" class="modal-input" placeholder="Weight" value="${edge.weight || 1}" step="0.1" min="0" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="updateEdge()">Update Edge</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.updateEdge;
            };
            
            window.updateEdge = () => {
                const type = document.getElementById('modal-edge-type').value;
                const weight = parseFloat(document.getElementById('modal-edge-weight').value) || 1;
                
                try {
                    // Update the edge
                    const edgeIndex = window.graphApp.state.currentGraph.edges.findIndex(e => 
                        e.source === edge.source && e.target === edge.target
                    );
                    if (edgeIndex !== -1) {
                        window.graphApp.state.currentGraph.edges[edgeIndex].type = type;
                        window.graphApp.state.currentGraph.edges[edgeIndex].weight = weight;
                        window.graphApp.dispatchEvent(new CustomEvent('graphUpdated', {
                            detail: { graph: window.graphApp.state.currentGraph }
                        }));
                        showStatus(`Edge "${edge.source} → ${edge.target}" updated successfully`, 'success');
                        closeModal();
                    }
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }

        function initializeEventHandlers() {
            // File operations (still needed for compatibility)
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        window.graphApp.importGraph(event.target.result);
                        showStatus(`Graph loaded from "${file.name}"`, 'success');
                    } catch (error) {
                        showStatus(`Failed to load graph: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            });

            // File operations (now handled by menu, but keeping for compatibility)
            // These elements no longer exist in toolbar but IDs might be referenced elsewhere

            // Graph operations handled by menu now

            // Analysis operations
            document.getElementById('run-analysis').addEventListener('click', () => {
                window.graphApp.triggerAnalysis();
            });

            // Listen for analysis events
            window.graphApp.addEventListener('analysisStarted', () => {
                document.getElementById('analysis-loading').classList.remove('hidden');
                document.getElementById('analysis-results').classList.add('hidden');
                document.getElementById('run-analysis').disabled = true;
            });

            window.graphApp.addEventListener('analysisCompleted', (e) => {
                document.getElementById('analysis-loading').classList.add('hidden');
                document.getElementById('analysis-results').classList.remove('hidden');
                document.getElementById('run-analysis').disabled = false;
                
                displayAnalysisResults(e.detail.results);
            });

            window.graphApp.addEventListener('analysisError', (e) => {
                document.getElementById('analysis-loading').classList.add('hidden');
                document.getElementById('run-analysis').disabled = false;
                showStatus(`Analysis failed: ${e.detail.error}`, 'error');
            });
        }

        async function initializeAnalysisSystem() {
            console.log('Initializing analysis system (basic mode)...');
            
            // For now, use basic JavaScript analysis instead of Python
            // This avoids the Pyodide loading issues
            window.graphApp.state.availablePlugins.set('causal-paths', {
                analyze: async (graph, params) => {
                    if (graph.nodes.length === 0) {
                        throw new Error('No nodes in graph to analyze');
                    }
                    
                    // Basic JavaScript analysis
                    const influenceScores = {};
                    const positivePaths = [];
                    const negativePaths = [];
                    
                    // Calculate basic influence scores (sum of incoming edge weights)
                    graph.nodes.forEach(node => {
                        let score = 0;
                        graph.edges.forEach(edge => {
                            if (edge.target === node.id) {
                                const weight = edge.type === '-' ? -edge.weight : edge.weight;
                                score += weight;
                            }
                        });
                        influenceScores[node.label || node.id] = score;
                    });
                    
                    // Find simple paths (just direct connections for now)
                    if (graph.nodes.length >= 2) {
                        const firstNode = graph.nodes[0];
                        const lastNode = graph.nodes[graph.nodes.length - 1];
                        
                        // Find direct connection
                        const directEdge = graph.edges.find(e => 
                            e.source === firstNode.id && e.target === lastNode.id
                        );
                        
                        if (directEdge) {
                            const path = [firstNode.label || firstNode.id, lastNode.label || lastNode.id];
                            if (directEdge.type === '+') {
                                positivePaths.push(path);
                            } else {
                                negativePaths.push(path);
                            }
                        }
                    }
                    
                    return {
                        metadata: {
                            analysis_id: 'causal-paths-basic',
                            analysis_name: 'Basic Causal Analysis',
                            timestamp: new Date().toISOString(),
                            parameters_used: params,
                            graph_stats: {
                                nodes: graph.nodes.length,
                                edges: graph.edges.length
                            }
                        },
                        results: {
                            primary: {
                                influence_scores: influenceScores,
                                positive_paths: positivePaths,
                                negative_paths: negativePaths
                            }
                        },
                        summary: `Basic analysis complete. Found ${Object.keys(influenceScores).length} nodes with influence scores, ${positivePaths.length} positive paths, ${negativePaths.length} negative paths.`
                    };
                }
            });
            
            console.log('Basic analysis system initialized');
        }
        
        function formatAnalysisSummary(results) {
            const lines = [];
            
            if (results.influence_scores) {
                const scores = Object.entries(results.influence_scores);
                if (scores.length > 0) {
                    const topNode = scores.reduce((a, b) => a[1] > b[1] ? a : b);
                    lines.push(`Highest influence: ${topNode[0]} (${topNode[1]})`);
                }
            }
            
            if (results.positive_paths && results.positive_paths.length > 0) {
                lines.push(`Found ${results.positive_paths.length} positive path(s)`);
            }
            
            if (results.negative_paths && results.negative_paths.length > 0) {
                lines.push(`Found ${results.negative_paths.length} negative path(s)`);
            }
            
            return lines.length > 0 ? lines.join('. ') + '.' : 'Analysis completed successfully.';
        }

        function displayAnalysisResults(results) {
            const container = document.getElementById('results-content');
            
            let html = `<div style="margin-bottom: 15px;"><strong>Summary:</strong> ${results.summary}</div>`;
            
            if (results.results && results.results.primary) {
                const primary = results.results.primary;
                
                // Display influence scores
                if (primary.influence_scores && Object.keys(primary.influence_scores).length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Influence Scores:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    Object.entries(primary.influence_scores).forEach(([node, score]) => {
                        html += `<div>${node}: ${score}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // Display positive paths
                if (primary.positive_paths && primary.positive_paths.length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Positive Paths:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    primary.positive_paths.forEach(path => {
                        html += `<div>${path.join(' → ')}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // Display negative paths
                if (primary.negative_paths && primary.negative_paths.length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Negative Paths:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    primary.negative_paths.forEach(path => {
                        html += `<div>${path.join(' → ')}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // If no meaningful results, show raw data
                if (!primary.influence_scores && !primary.positive_paths && !primary.negative_paths) {
                    html += `<div><strong>Raw Results:</strong>
                        <pre style="font-size: 12px;">${JSON.stringify(primary, null, 2)}</pre></div>`;
                }
            }
            
            container.innerHTML = html;
        }

        function showStatus(message, type = 'info') {
            const container = document.getElementById('status-container');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
            
            container.appendChild(statusDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const editorNetwork = window.graphApp.networks.editor;
            const analysisNetwork = window.graphApp.networks.analysis;
            
            if (editorNetwork) {
                editorNetwork.fit();
            }
            if (analysisNetwork) {
                analysisNetwork.fit();
            }
        });
    </script>
</body>
</html>