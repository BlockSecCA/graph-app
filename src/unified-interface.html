<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Causal Graph Tool</title>
    
    <!-- External Dependencies -->
    <script src="https://unpkg.com/vis-network@latest/standalone/umd/vis-network.min.js"></script>
    <script src="../lib/pyodide/pyodide.js"></script>
    
    <!-- Application Styles -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #f5f5f5;
        }

        /* Top Toolbar */
        .toolbar {
            height: 60px;
            background: #2c3e50;
            color: white;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            z-index: 1000;
        }

        .toolbar h1 {
            font-size: 18px;
            margin-right: 30px;
        }

        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .toolbar-section:not(:last-child) {
            margin-right: 30px;
            padding-right: 30px;
            border-right: 1px solid #34495e;
        }

        .toolbar button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .toolbar button:hover {
            background: #2980b9;
        }

        .toolbar button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        .toolbar select {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #bdc3c7;
            font-size: 14px;
        }

        .toolbar input[type="file"] {
            display: none;
        }

        .toolbar label {
            background: #27ae60;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .toolbar label:hover {
            background: #229954;
        }

        .toolbar-input {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            min-width: 80px;
        }

        .toolbar-input.small {
            min-width: 60px;
            max-width: 80px;
        }

        .toolbar-select {
            padding: 6px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            min-width: 50px;
        }

        .toolbar button.danger {
            background: #e74c3c;
        }

        .toolbar button.danger:hover {
            background: #c0392b;
        }

        /* Main Content Area */
        .main-content {
            height: calc(100vh - 60px);
            display: flex;
        }

        /* Split Pane Container */
        .split-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Editor Pane */
        .editor-pane {
            flex: 1;
            min-width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #ddd;
            position: relative;  /* Ensure controls stay within pane */
        }

        .editor-header {
            padding: 15px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            font-weight: 600;
            color: #2c3e50;
        }


        .vis-network {
            flex: 1;
            width: 100%;
            background: white;
        }

        /* Resizable Splitter */
        .splitter {
            width: 5px;
            background: #bdc3c7;
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
        }

        .splitter:hover {
            background: #95a5a6;
        }

        .splitter::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 30px;
            background: #7f8c8d;
            border-radius: 2px;
        }

        /* Analysis Pane */
        .analysis-pane {
            flex: 1;
            min-width: 400px;
            background: white;
            display: flex;
            flex-direction: column;
        }

        .analysis-header {
            padding: 15px 20px;
            background: #ecf0f1;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .analysis-header h2 {
            font-weight: 600;
            color: #2c3e50;
            margin: 0;
        }

        .plugin-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .plugin-selector select {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .run-analysis-btn {
            padding: 8px 16px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .run-analysis-btn:hover {
            background: #229954;
        }

        .run-analysis-btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }

        /* Analysis Results */
        .analysis-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .analysis-results {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .analysis-results h3 {
            margin: 0 0 10px 0;
            color: #2c3e50;
            font-size: 16px;
        }

        .analysis-results pre {
            background: white;
            padding: 12px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre-wrap;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 40px;
            color: #7f8c8d;
        }

        .loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Status Messages */
        .status-message {
            padding: 10px 15px;
            margin: 10px 20px;
            border-radius: 4px;
            font-size: 14px;
        }

        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .split-container {
                flex-direction: column;
            }
            
            .splitter {
                width: 100%;
                height: 5px;
                cursor: row-resize;
            }
            
            .editor-pane,
            .analysis-pane {
                min-width: unset;
                min-height: 300px;
            }
            
            .toolbar {
                flex-wrap: wrap;
                height: auto;
                min-height: 60px;
            }
            
            .toolbar-section {
                margin-right: 15px;
                padding-right: 15px;
            }
        }


        /* Context Menu Styles */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10000;
            min-width: 150px;
            padding: 4px 0;
            font-size: 14px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f5f5f5;
        }

        .context-menu-item.danger {
            color: #e74c3c;
        }

        .context-menu-item.danger:hover {
            background: #fdf2f2;
        }

        .context-menu-separator {
            height: 1px;
            background: #eee;
            margin: 4px 0;
        }

        /* Modal dialog styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
        }

        .modal-dialog {
            background: white;
            border-radius: 6px;
            padding: 20px;
            min-width: 300px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }

        .modal-title {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .modal-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-bottom: 10px;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .modal-button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .modal-button.primary {
            background: #3498db;
            color: white;
        }

        .modal-button.primary:hover {
            background: #2980b9;
        }

        .modal-button.secondary {
            background: #95a5a6;
            color: white;
        }

        .modal-button.secondary:hover {
            background: #7f8c8d;
        }

        /* Hide elements when not needed */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Top Toolbar -->
    <div class="toolbar">
        <div class="toolbar-section">
            <span>Nodes: <span id="node-count">0</span></span>
            <span>Edges: <span id="edge-count">0</span></span>
        </div>
        
        <div class="toolbar-section">
            <span id="mode-indicator">Right-click canvas to add nodes</span>
        </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <div class="split-container">
            <!-- Editor Pane -->
            <div class="editor-pane">
                <div class="editor-header">
                    <h2>Graph Editor</h2>
                </div>
                
                <!-- Graph Network (takes full space) -->
                <div id="editor-network" class="vis-network"></div>
            </div>

            <!-- Resizable Splitter -->
            <div class="splitter" id="splitter"></div>

            <!-- Analysis Pane -->
            <div class="analysis-pane">
                <div class="analysis-header">
                    <h2>Analysis</h2>
                    <div class="plugin-selector">
                        <select id="plugin-select">
                            <option value="causal-paths">Causal Path Analysis</option>
                            <option value="centrality" disabled>Centrality (Coming Soon)</option>
                            <option value="community" disabled>Community Detection (Coming Soon)</option>
                        </select>
                        <button id="run-analysis" class="run-analysis-btn">Analyze</button>
                    </div>
                </div>
                
                <!-- Analysis Content -->
                <div class="analysis-content">
                    <div id="analysis-placeholder" class="analysis-results">
                        <h3>Ready to Analyze</h3>
                        <p>Create a graph in the editor and click "Analyze" to see results.</p>
                        <p>Analysis will run automatically as you make changes to the graph.</p>
                    </div>
                    
                    <div id="analysis-loading" class="loading hidden">
                        Analyzing graph...
                    </div>
                    
                    <div id="analysis-results" class="analysis-results hidden">
                        <h3>Analysis Results</h3>
                        <div id="results-content"></div>
                    </div>
                    
                    <!-- Graph Visualization for Analysis -->
                    <div id="analysis-visualization" class="graph-container hidden" data-container-type="analysis" style="height: 300px; margin-top: 20px;">
                        <div id="analysis-network" class="vis-network"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Messages Container -->
    <div id="status-container"></div>

    <!-- Hidden file input for menu operations -->
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <!-- Include Shared State -->
    <script src="shared-state.js"></script>

    <!-- Main Application Script -->
    <script>
        // Initialize the unified interface
        document.addEventListener('DOMContentLoaded', function() {
            initializeUnifiedInterface();
            
            // Set up IPC listeners for menu commands
            if (window.require) {
                try {
                    const { ipcRenderer } = window.require('electron');
                    console.log('IPC Renderer available, setting up menu listeners...');
                    
                    ipcRenderer.on('menu-load-graph-content', (event, fileContent, fileName) => {
                        console.log('Menu: Load Graph content received');
                        try {
                            window.graphApp.importGraph(fileContent);
                            showStatus(`Graph loaded from "${fileName}"`, 'success');
                        } catch (error) {
                            showStatus(`Failed to load graph: ${error.message}`, 'error');
                        }
                    });
                    
                    ipcRenderer.on('menu-save-graph', () => {
                        console.log('Menu: Save Graph clicked');
                        saveGraphFile();
                    });
                    
                    ipcRenderer.on('menu-fit-graph', () => {
                        console.log('Menu: Fit Graph clicked');
                        const network = window.graphApp.networks.editor;
                        if (network) {
                            network.fit();
                        }
                    });
                    
                } catch (error) {
                    console.error('Failed to set up IPC listeners:', error);
                }
            } else {
                console.warn('window.require not available, menu shortcuts will not work');
            }
        });

        async function initializeUnifiedInterface() {
            console.log('Initializing Causal Graph Tool...');
            
            // Initialize shared state
            const app = window.graphApp;
            
            // Initialize networks
            initializeEditorNetwork();
            initializeSplitter();
            initializeEventHandlers();
            
            // Initialize analysis system (placeholder for now)
            await initializeAnalysisSystem();
            
            console.log('Application initialized successfully');
        }

        function initializeEditorNetwork() {
            const container = document.getElementById('editor-network');
            
            const options = {
                nodes: {
                    shape: 'dot',
                    size: 16,
                    font: { color: '#2c3e50', size: 14 },
                    borderWidth: 2,
                    shadow: true
                },
                edges: {
                    arrows: { to: { enabled: true, scaleFactor: 1.2 } },
                    smooth: { type: 'curvedCW', roundness: 0.1 },
                    font: { color: '#34495e', size: 12, align: 'middle' },
                    shadow: true
                },
                physics: {
                    enabled: true,
                    stabilization: { 
                        enabled: true,
                        iterations: 500,
                        updateInterval: 25
                    },
                    barnesHut: {
                        gravitationalConstant: -2000,
                        centralGravity: 0.3,
                        springLength: 95,
                        springConstant: 0.04,
                        damping: 0.09
                    }
                },
                interaction: {
                    hover: true,
                    selectConnectedEdges: false
                },
                // Force vis-network to use full container size
                autoResize: true,
                width: '100%',
                height: '100%'
            };

            // Create the vis-network
            const editorNetwork = new vis.Network(container, { nodes: new vis.DataSet(), edges: new vis.DataSet() }, options);
            
            // Force resize to container dimensions
            function resizeNetwork() {
                const rect = container.getBoundingClientRect();
                editorNetwork.setSize(rect.width + 'px', rect.height + 'px');
                editorNetwork.fit();
            }
            
            // Initial resize
            setTimeout(resizeNetwork, 100);
            
            // Resize on window resize
            window.addEventListener('resize', resizeNetwork);
            
            // Register with shared state
            window.graphApp.registerNetwork('editor', editorNetwork);
            
            // Listen for graph updates
            window.graphApp.addEventListener('graphUpdated', (e) => {
                updateNetworkData(editorNetwork, e.detail.graph);
                updateStats(e.detail.graph);
            });
            
            // Add context menu support
            setupContextMenus(editorNetwork);
        }

        function updateNetworkData(network, graphData) {
            console.log('Updating network with graph data:', graphData);
            
            // Always create fresh DataSets (identical to app startup behavior)
            const nodes = new vis.DataSet();
            const edges = new vis.DataSet();
            
            // Add new nodes
            const nodeData = graphData.nodes.map((node, index) => {
                const nodeData = {
                    id: node.id,
                    label: node.label || node.id,
                    group: node.group || 'default',
                    title: `${node.label || node.id}\nType: ${node.type || 'N/A'}\nGroup: ${node.group || 'default'}`,
                    // Use provided positions or let physics handle it
                    x: node.x,
                    y: node.y
                };
                console.log('Creating node for network:', nodeData);
                return nodeData;
            });
            
            // Add new edges
            const edgeData = graphData.edges.map(edge => ({
                id: `${edge.source}-${edge.target}`,
                from: edge.source,
                to: edge.target,
                label: edge.type + (edge.weight !== 1 ? ` (${edge.weight})` : ''),
                color: edge.type === '+' ? '#27ae60' : '#e74c3c',
                width: Math.abs(edge.weight) * 2,
                title: `${edge.source} → ${edge.target}\nType: ${edge.type}\nWeight: ${edge.weight}`
            }));
            
            // Add data to fresh datasets
            if (nodeData.length > 0) {
                nodes.add(nodeData);
            }
            if (edgeData.length > 0) {
                edges.add(edgeData);
            }
            
            // Update network with fresh DataSets (identical to app startup)
            network.setData({ nodes, edges });
            console.log('Network updated with fresh DataSets');
            
            // Ensure nodes are visible by fitting the view
            if (graphData.nodes.length > 0) {
                setTimeout(() => {
                    network.fit({
                        animation: {
                            duration: 1000,
                            easingFunction: 'easeInOutQuad'
                        }
                    });
                }, 300);
            }
        }

        function updateStats(graphData) {
            document.getElementById('node-count').textContent = graphData.nodes.length;
            document.getElementById('edge-count').textContent = graphData.edges.length;
            
            // Debug: Log node positions
            if (graphData.nodes.length > 0) {
                console.log('Current nodes:', graphData.nodes);
                
                // Auto-fit if we have nodes but they might be invisible
                setTimeout(() => {
                    const network = window.graphApp.networks.editor;
                    if (network) {
                        network.fit();
                    }
                }, 200);
            }
        }

        function setupContextMenus(network) {
            let contextMenu = null;
            let contextPosition = { x: 0, y: 0 };
            let contextNodeId = null;
            let contextEdgeId = null;
            
            // Disable default context menu
            const container = document.getElementById('editor-network');
            console.log('Setting up context menu on container:', container);
            
            // Ensure network is fully initialized before setting up events
            network.once('stabilizationIterationsDone', () => {
                console.log('Network stabilized, context menus are ready');
            });
            
            // Disable default browser context menu
            container.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });
            
            // Use vis-network's oncontext event exclusively for better reliability
            network.on('oncontext', (params) => {
                console.log('vis-network oncontext event:', params);
                if (params.event && params.event.preventDefault) {
                    params.event.preventDefault();
                    
                    const canvasPosition = { x: params.pointer.canvas.x, y: params.pointer.canvas.y };
                    const domPosition = { x: params.pointer.DOM.x, y: params.pointer.DOM.y };
                    
                    console.log('Context menu triggered at DOM:', domPosition, 'Canvas:', canvasPosition);
                    
                    if (params.nodes && params.nodes.length > 0) {
                        console.log('Right-clicked on node:', params.nodes[0]);
                        showNodeContextMenu(domPosition.x, domPosition.y, params.nodes[0]);
                    } else if (params.edges && params.edges.length > 0) {
                        console.log('Right-clicked on edge:', params.edges[0]);
                        showEdgeContextMenu(domPosition.x, domPosition.y, params.edges[0]);
                    } else {
                        console.log('Right-clicked on canvas, showing add node menu');
                        showCanvasContextMenu(domPosition.x, domPosition.y, canvasPosition);
                    }
                }
            });
            
            // Close context menu on click elsewhere (but not on modal dialogs)
            document.addEventListener('click', (e) => {
                // Don't close context menu if clicking on modal elements
                if (!e.target.closest('.modal-overlay') && !e.target.closest('.context-menu')) {
                    closeContextMenu();
                }
            });
            
            // Close context menu on escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeContextMenu();
                }
            });
            
            function closeContextMenu() {
                if (contextMenu) {
                    document.body.removeChild(contextMenu);
                    contextMenu = null;
                }
            }
            
            function showCanvasContextMenu(x, y, canvasPosition) {
                closeContextMenu();
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const addNodeItem = document.createElement('button');
                addNodeItem.className = 'context-menu-item';
                addNodeItem.innerHTML = '➕ Add Node';
                addNodeItem.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    closeContextMenu();
                    // Small delay to ensure event handling is complete
                    setTimeout(() => {
                        showAddNodeDialog(canvasPosition);
                    }, 10);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const addEdgeItem = document.createElement('button');
                addEdgeItem.className = 'context-menu-item';
                addEdgeItem.innerHTML = '🔗 Add Edge';
                addEdgeItem.onclick = (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    closeContextMenu();
                    // Small delay to ensure event handling is complete
                    setTimeout(() => {
                        showAddEdgeDialog();
                    }, 10);
                };
                
                contextMenu.appendChild(addNodeItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(addEdgeItem);
                document.body.appendChild(contextMenu);
            }
            
            function showNodeContextMenu(x, y, nodeId) {
                closeContextMenu();
                
                const node = window.graphApp.state.currentGraph.nodes.find(n => n.id === nodeId);
                if (!node) return;
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const editItem = document.createElement('button');
                editItem.className = 'context-menu-item';
                editItem.innerHTML = '✏️ Edit Node';
                editItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showEditNodeDialog(node);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const deleteItem = document.createElement('button');
                deleteItem.className = 'context-menu-item danger';
                deleteItem.innerHTML = '🗑️ Delete Node';
                deleteItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (confirm(`Delete node "${node.label || node.id}"?`)) {
                        window.graphApp.deleteNode(nodeId);
                        showStatus(`Node "${node.label || node.id}" deleted`, 'success');
                    }
                };
                
                contextMenu.appendChild(editItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(deleteItem);
                document.body.appendChild(contextMenu);
            }
            
            function showEdgeContextMenu(x, y, edgeId) {
                closeContextMenu();
                console.log('Looking for edge with ID:', edgeId);
                console.log('Available edges:', window.graphApp.state.currentGraph.edges);
                
                const edge = window.graphApp.state.currentGraph.edges.find(e => 
                    `${e.source}-${e.target}` === edgeId
                );
                console.log('Found edge:', edge);
                if (!edge) {
                    console.warn('Edge not found for ID:', edgeId);
                    return;
                }
                
                contextMenu = document.createElement('div');
                contextMenu.className = 'context-menu';
                contextMenu.style.left = x + 'px';
                contextMenu.style.top = y + 'px';
                
                const editItem = document.createElement('button');
                editItem.className = 'context-menu-item';
                editItem.innerHTML = '✏️ Edit Edge';
                editItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    showEditEdgeDialog(edge);
                };
                
                const separator = document.createElement('div');
                separator.className = 'context-menu-separator';
                
                const deleteItem = document.createElement('button');
                deleteItem.className = 'context-menu-item danger';
                deleteItem.innerHTML = '🗑️ Delete Edge';
                deleteItem.onclick = (e) => {
                    e.stopPropagation();
                    closeContextMenu();
                    if (confirm(`Delete edge "${edge.source} → ${edge.target}"?`)) {
                        window.graphApp.deleteEdge(edge.source, edge.target);
                        showStatus(`Edge "${edge.source} → ${edge.target}" deleted`, 'success');
                    }
                };
                
                contextMenu.appendChild(editItem);
                contextMenu.appendChild(separator);
                contextMenu.appendChild(deleteItem);
                document.body.appendChild(contextMenu);
            }
        }

        function initializeSplitter() {
            const splitter = document.getElementById('splitter');
            const container = document.querySelector('.split-container');
            const editorPane = document.querySelector('.editor-pane');
            const analysisPane = document.querySelector('.analysis-pane');
            
            let isResizing = false;
            
            splitter.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.addEventListener('mousemove', handleResize);
                document.addEventListener('mouseup', stopResize);
                e.preventDefault();
            });
            
            function handleResize(e) {
                if (!isResizing) return;
                
                const containerRect = container.getBoundingClientRect();
                const x = e.clientX - containerRect.left;
                const containerWidth = containerRect.width;
                
                // Calculate percentages
                const leftPercent = (x / containerWidth) * 100;
                const rightPercent = 100 - leftPercent;
                
                // Enforce minimum widths (30% each)
                if (leftPercent >= 30 && rightPercent >= 30) {
                    editorPane.style.flex = `0 0 ${leftPercent}%`;
                    analysisPane.style.flex = `0 0 ${rightPercent}%`;
                    
                    // Trigger network resize and control adaptation
                    setTimeout(() => {
                        const editorNetwork = window.graphApp.networks.editor;
                        const analysisNetwork = window.graphApp.networks.analysis;
                        
                        if (editorNetwork) {
                            const editorContainer = document.getElementById('editor-network');
                            const rect = editorContainer.getBoundingClientRect();
                            editorNetwork.setSize(rect.width + 'px', rect.height + 'px');
                            editorNetwork.fit();
                        }
                        if (analysisNetwork) {
                            analysisNetwork.fit();
                        }
                    }, 50);
                }
            }
            
            function stopResize() {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.removeEventListener('mousemove', handleResize);
                document.removeEventListener('mouseup', stopResize);
            }
        }

        function saveGraphFile() {
            try {
                const jsonData = window.graphApp.exportGraph();
                const blob = new Blob([jsonData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'graph.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showStatus('Graph saved successfully', 'success');
            } catch (error) {
                showStatus(`Failed to save graph: ${error.message}`, 'error');
            }
        }

        function showAddNodeDialog(canvasPosition) {
            console.log('showAddNodeDialog called with position:', canvasPosition);
            
            // Remove any existing modals first
            const existingModals = document.querySelectorAll('.modal-overlay');
            existingModals.forEach(modal => modal.remove());
            
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Add New Node</h3>
                <input type="text" id="modal-node-id" class="modal-input" placeholder="Node ID (required)" />
                <input type="text" id="modal-node-label" class="modal-input" placeholder="Node Label (optional)" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="createNode()">Add Node</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            console.log('Modal dialog created and added to DOM');
            
            // Handle overlay clicks - close modal if clicking overlay, prevent propagation otherwise
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    // Clicking the overlay itself (not the dialog)
                    closeModal();
                } else {
                    // Clicking something inside the dialog - prevent propagation
                    e.stopPropagation();
                }
            });
            
            
            // Focus the first input with better error handling
            setTimeout(() => {
                const input = document.getElementById('modal-node-id');
                if (input) {
                    input.focus();
                    input.select(); // Select text to make it obvious it's focused
                    console.log('Input focused and selected successfully');
                    
                    // Test if input works by adding a test listener
                    input.addEventListener('input', (e) => {
                        console.log('Input event detected:', e.target.value);
                    });
                    
                } else {
                    console.error('Could not find modal-node-id input element');
                }
            }, 150);
            
            // Handle enter key
            dialog.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createNode();
                }
            });
            
            window.closeModal = () => {
                if (overlay && overlay.parentNode) {
                    document.body.removeChild(overlay);
                }
                delete window.closeModal;
                delete window.createNode;
                console.log('Modal closed and cleaned up');
            };
            
            window.createNode = () => {
                const id = document.getElementById('modal-node-id').value.trim();
                const label = document.getElementById('modal-node-label').value.trim();
                
                if (!id) {
                    showStatus('Please enter a node ID', 'error');
                    return;
                }
                
                try {
                    // Add node with explicit position if we have canvas position
                    const nodeData = { 
                        id, 
                        label: label || id
                    };
                    
                    // Add position data - use canvas position if available, otherwise let physics handle it
                    if (canvasPosition && canvasPosition.x !== undefined && canvasPosition.y !== undefined && 
                        Math.abs(canvasPosition.x) < 500 && Math.abs(canvasPosition.y) < 500) {
                        // Use canvas position if it's within reasonable bounds
                        nodeData.x = canvasPosition.x;
                        nodeData.y = canvasPosition.y;
                        console.log('Adding node at canvas position:', canvasPosition);
                    } else {
                        // Let physics determine position, but give a hint near other nodes
                        const existingNodes = window.graphApp.state.currentGraph.nodes;
                        if (existingNodes.length > 0) {
                            // Place near the center of existing nodes
                            const avgX = existingNodes.reduce((sum, n) => sum + (n.x || 0), 0) / existingNodes.length;
                            const avgY = existingNodes.reduce((sum, n) => sum + (n.y || 0), 0) / existingNodes.length;
                            nodeData.x = avgX + (Math.random() - 0.5) * 100;
                            nodeData.y = avgY + (Math.random() - 0.5) * 100;
                        }
                        // If no existing nodes, let physics place it (no x,y specified)
                        console.log('Adding node with physics positioning:', nodeData.x ? { x: nodeData.x, y: nodeData.y } : 'auto');
                    }
                    
                    console.log('Adding node with data:', nodeData);
                    window.graphApp.addNode(nodeData);
                    showStatus(`Node "${id}" added successfully`, 'success');
                    closeModal();
                    
                    // Force network to fit view to show new node
                    setTimeout(() => {
                        const network = window.graphApp.networks.editor;
                        if (network) {
                            network.fit({
                                animation: {
                                    duration: 500,
                                    easingFunction: 'easeInOutQuad'
                                }
                            });
                        }
                    }, 200);
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showEditNodeDialog(node) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Edit Node</h3>
                <input type="text" id="modal-node-id" class="modal-input" placeholder="Node ID" value="${node.id}" readonly style="background: #f5f5f5;" />
                <input type="text" id="modal-node-label" class="modal-input" placeholder="Node Label" value="${node.label || ''}" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="updateNode()">Update Node</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the label input
            setTimeout(() => {
                document.getElementById('modal-node-label').focus();
            }, 100);
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.updateNode;
            };
            
            window.updateNode = () => {
                const label = document.getElementById('modal-node-label').value.trim();
                
                try {
                    // Update the node label
                    const nodeIndex = window.graphApp.state.currentGraph.nodes.findIndex(n => n.id === node.id);
                    if (nodeIndex !== -1) {
                        window.graphApp.state.currentGraph.nodes[nodeIndex].label = label || node.id;
                        window.graphApp.dispatchEvent(new CustomEvent('graphUpdated', {
                            detail: { graph: window.graphApp.state.currentGraph }
                        }));
                        showStatus(`Node "${node.id}" updated successfully`, 'success');
                        closeModal();
                    }
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showEditEdgeDialog(edge) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            dialog.innerHTML = `
                <h3 class="modal-title">Edit Edge</h3>
                <input type="text" id="modal-edge-source" class="modal-input" value="${edge.source}" readonly style="background: #f5f5f5;" />
                <input type="text" id="modal-edge-target" class="modal-input" value="${edge.target}" readonly style="background: #f5f5f5;" />
                <select id="modal-edge-type" class="modal-input">
                    <option value="+" ${edge.type === '+' ? 'selected' : ''}>Positive (+)</option>
                    <option value="-" ${edge.type === '-' ? 'selected' : ''}>Negative (-)</option>
                </select>
                <input type="number" id="modal-edge-weight" class="modal-input" placeholder="Weight" value="${edge.weight || 1}" step="0.1" min="0" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="updateEdge()">Update Edge</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.updateEdge;
            };
            
            window.updateEdge = () => {
                const type = document.getElementById('modal-edge-type').value;
                const weight = parseFloat(document.getElementById('modal-edge-weight').value) || 1;
                
                try {
                    // Update the edge
                    const edgeIndex = window.graphApp.state.currentGraph.edges.findIndex(e => 
                        e.source === edge.source && e.target === edge.target
                    );
                    if (edgeIndex !== -1) {
                        window.graphApp.state.currentGraph.edges[edgeIndex].type = type;
                        window.graphApp.state.currentGraph.edges[edgeIndex].weight = weight;
                        window.graphApp.dispatchEvent(new CustomEvent('graphUpdated', {
                            detail: { graph: window.graphApp.state.currentGraph }
                        }));
                        showStatus(`Edge "${edge.source} → ${edge.target}" updated successfully`, 'success');
                        closeModal();
                    }
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }
        
        function showAddEdgeDialog() {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            const dialog = document.createElement('div');
            dialog.className = 'modal-dialog';
            
            // Get existing node IDs for suggestions
            const nodeIds = window.graphApp.state.currentGraph.nodes.map(n => n.id);
            const nodeOptions = nodeIds.map(id => `<option value="${id}">${id}</option>`).join('');
            
            dialog.innerHTML = `
                <h3 class="modal-title">Add New Edge</h3>
                <select id="modal-edge-source" class="modal-input">
                    <option value="">Select Source Node</option>
                    ${nodeOptions}
                </select>
                <select id="modal-edge-target" class="modal-input">
                    <option value="">Select Target Node</option>
                    ${nodeOptions}
                </select>
                <select id="modal-edge-type" class="modal-input">
                    <option value="+">Positive (+)</option>
                    <option value="-">Negative (-)</option>
                </select>
                <input type="number" id="modal-edge-weight" class="modal-input" placeholder="Weight" value="1" step="0.1" min="0" />
                <div class="modal-buttons">
                    <button class="modal-button secondary" onclick="closeModal()">Cancel</button>
                    <button class="modal-button primary" onclick="createEdge()">Add Edge</button>
                </div>
            `;
            
            overlay.appendChild(dialog);
            document.body.appendChild(overlay);
            
            // Focus the first select
            setTimeout(() => {
                document.getElementById('modal-edge-source').focus();
            }, 100);
            
            // Handle enter key
            dialog.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    createEdge();
                }
            });
            
            window.closeModal = () => {
                document.body.removeChild(overlay);
                delete window.closeModal;
                delete window.createEdge;
            };
            
            window.createEdge = () => {
                const source = document.getElementById('modal-edge-source').value.trim();
                const target = document.getElementById('modal-edge-target').value.trim();
                const type = document.getElementById('modal-edge-type').value;
                const weight = parseFloat(document.getElementById('modal-edge-weight').value) || 1;
                
                if (!source) {
                    showStatus('Please select a source node', 'error');
                    return;
                }
                
                if (!target) {
                    showStatus('Please select a target node', 'error');
                    return;
                }
                
                if (source === target) {
                    showStatus('Source and target cannot be the same node', 'error');
                    return;
                }
                
                try {
                    const edgeData = { 
                        source, 
                        target, 
                        type,
                        weight 
                    };
                    
                    console.log('Adding edge with data:', edgeData);
                    window.graphApp.addEdge(edgeData);
                    showStatus(`Edge "${source} → ${target}" added successfully`, 'success');
                    closeModal();
                    
                } catch (error) {
                    showStatus(error.message, 'error');
                }
            };
        }

        function initializeEventHandlers() {
            // File operations (still needed for compatibility)
            document.getElementById('file-input').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        window.graphApp.importGraph(event.target.result);
                        showStatus(`Graph loaded from "${file.name}"`, 'success');
                    } catch (error) {
                        showStatus(`Failed to load graph: ${error.message}`, 'error');
                    }
                };
                reader.readAsText(file);
            });

            // File operations (now handled by menu, but keeping for compatibility)
            // These elements no longer exist in toolbar but IDs might be referenced elsewhere

            // Graph operations handled by menu now

            // Analysis operations
            document.getElementById('run-analysis').addEventListener('click', () => {
                window.graphApp.triggerAnalysis();
            });
            
            // Plugin selection change
            document.getElementById('plugin-select').addEventListener('change', (e) => {
                const selectedPlugin = e.target.value;
                if (selectedPlugin) {
                    console.log('Plugin selected:', selectedPlugin);
                    window.graphApp.setPlugin(selectedPlugin);
                }
            });

            // Listen for analysis events
            window.graphApp.addEventListener('analysisStarted', () => {
                document.getElementById('analysis-loading').classList.remove('hidden');
                document.getElementById('analysis-results').classList.add('hidden');
                document.getElementById('run-analysis').disabled = true;
            });

            window.graphApp.addEventListener('analysisCompleted', (e) => {
                document.getElementById('analysis-loading').classList.add('hidden');
                document.getElementById('analysis-results').classList.remove('hidden');
                document.getElementById('run-analysis').disabled = false;
                
                displayAnalysisResults(e.detail.results);
            });

            window.graphApp.addEventListener('analysisError', (e) => {
                document.getElementById('analysis-loading').classList.add('hidden');
                document.getElementById('run-analysis').disabled = false;
                showStatus(`Analysis failed: ${e.detail.error}`, 'error');
            });
        }

        // Test if Pyodide itself is the issue or something else
        let pyodideReadyPromise = null;
        
        async function testBasicPyodide() {
            try {
                console.log('🧪 Testing: Basic Pyodide loading...');
                const pyodide = await loadPyodide();
                console.log('✅ SUCCESS: Pyodide loaded');
                
                console.log('🧪 Testing: Basic Python execution...');
                pyodide.runPython('print("Hello from Python!")');
                console.log('✅ SUCCESS: Python execution works');
                
                console.log('🧪 Testing: NetworkX package loading...');
                await pyodide.loadPackage(['networkx']);
                console.log('✅ SUCCESS: NetworkX loaded');
                
                console.log('🧪 Testing: NetworkX import...');
                pyodide.runPython(`
import networkx as nx
G = nx.Graph()
G.add_edge(1, 2)
print(f"NetworkX works: {G.number_of_nodes()} nodes")
                `);
                console.log('✅ SUCCESS: NetworkX import and usage works');
                
                return pyodide;
            } catch (error) {
                console.error('❌ FAILED: Pyodide test failed at:', error.message);
                console.error('Full error:', error);
                throw error;
            }
        }
        
        // Start the basic test immediately
        pyodideReadyPromise = testBasicPyodide();
        
        async function initializeAnalysisSystem() {
            console.log('🔬 Analysis system: Waiting for Pyodide test results...');
            
            try {
                // Wait for Pyodide test to complete
                window.pyodide = await pyodideReadyPromise;
                console.log('🔬 Analysis system: Pyodide test passed, continuing with plugins...');
                
                // Use simple plugin directory for testing
                const pluginsDirectory = 'py/plugins';
                console.log('🔬 Using plugins directory:', pluginsDirectory);
                
                // Load plugin loader module
                const pluginLoaderResponse = await fetch('py/plugin_loader.py');
                const pluginLoaderCode = await pluginLoaderResponse.text();
                window.pyodide.runPython(pluginLoaderCode);
                console.log('Plugin loader loaded');
                
                // Set plugins directory in Python
                window.pyodide.runPython(`
import js
_plugin_loader = None
from plugin_loader import PluginLoader
_plugin_loader = PluginLoader("${pluginsDirectory.replace(/\\/g, '/')}")
print(f"Plugin loader initialized with directory: ${pluginsDirectory.replace(/\\/g, '/')}")
                `);
                
                // Discover plugins
                await discoverPlugins();
                
                console.log('Plugin-based analysis system initialized');
                
            } catch (error) {
                console.error('Failed to initialize plugin system, falling back to basic mode:', error);
                await initializeFallbackAnalysis();
            }
        }
        
        async function discoverPlugins() {
            try {
                // Run plugin discovery
                const result = window.pyodide.runPython(`discover_plugins_js()`);
                const discovery = JSON.parse(result);
                
                if (!discovery.success) {
                    throw new Error(discovery.error);
                }
                
                console.log('Discovered plugins:', discovery.plugins);
                
                // Register plugins with shared state
                window.graphApp.state.availablePlugins.clear();
                
                for (const plugin of discovery.plugins) {
                    window.graphApp.state.availablePlugins.set(plugin.id, {
                        info: plugin,
                        analyze: async (graph, params) => {
                            return await executePlugin(plugin.id, graph, params);
                        }
                    });
                }
                
                // Update plugin dropdown
                updatePluginDropdown(discovery.plugins);
                
                // Show any plugin loading errors
                if (Object.keys(discovery.errors).length > 0) {
                    console.warn('Plugin loading errors:', discovery.errors);
                    for (const [plugin, error] of Object.entries(discovery.errors)) {
                        showStatus(`Plugin ${plugin} failed to load: ${error}`, 'warning');
                    }
                }
                
            } catch (error) {
                console.error('Plugin discovery failed:', error);
                throw error;
            }
        }
        
        async function executePlugin(pluginId, graph, parameters) {
            try {
                // Ensure NetworkX is loaded before plugin execution
                if (!window.networkXLoaded) {
                    console.log('Loading NetworkX for plugin execution...');
                    await window.pyodide.loadPackage(['networkx']);
                    window.networkXLoaded = true;
                    console.log('NetworkX loaded successfully');
                }
                
                const nodesJson = JSON.stringify(graph.nodes);
                const edgesJson = JSON.stringify(graph.edges);
                const paramsJson = JSON.stringify(parameters || {});
                
                const result = window.pyodide.runPython(`
execute_plugin_js('${pluginId}', '''${nodesJson}''', '''${edgesJson}''', '''${paramsJson}''')
                `);
                
                const response = JSON.parse(result);
                
                if (!response.success) {
                    throw new Error(response.error);
                }
                
                return response.results;
                
            } catch (error) {
                console.error(`Plugin ${pluginId} execution failed:`, error);
                throw error;
            }
        }
        
        function updatePluginDropdown(plugins) {
            const select = document.getElementById('plugin-select');
            
            // Clear existing options
            select.innerHTML = '';
            
            // Add discovered plugins
            for (const plugin of plugins) {
                const option = document.createElement('option');
                option.value = plugin.id;
                option.textContent = plugin.name;
                option.title = plugin.description;
                select.appendChild(option);
            }
            
            // If no plugins found, add placeholder
            if (plugins.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = 'No plugins available';
                option.disabled = true;
                select.appendChild(option);
            }
            
            // Select first plugin if available
            if (plugins.length > 0) {
                window.graphApp.setPlugin(plugins[0].id);
            }
        }
        
        async function initializeFallbackAnalysis() {
            console.log('Initializing fallback analysis system...');
            
            // Fallback to basic JavaScript analysis if Python fails
            window.graphApp.state.availablePlugins.set('basic-analysis', {
                info: {
                    id: 'basic-analysis',
                    name: 'Basic Analysis (Fallback)',
                    description: 'Simple JavaScript-based analysis when Python plugins fail'
                },
                analyze: async (graph, params) => {
                    if (graph.nodes.length === 0) {
                        throw new Error('No nodes in graph to analyze');
                    }
                    
                    // Basic influence scores
                    const influenceScores = {};
                    graph.nodes.forEach(node => {
                        let score = 0;
                        graph.edges.forEach(edge => {
                            if (edge.target === node.id) {
                                const weight = edge.type === '-' ? -edge.weight : edge.weight;
                                score += weight;
                            }
                        });
                        influenceScores[node.label || node.id] = score;
                    });
                    
                    return {
                        metadata: {
                            analysis_id: 'basic-analysis',
                            analysis_name: 'Basic Analysis (Fallback)',
                            timestamp: new Date().toISOString()
                        },
                        results: {
                            primary: {
                                influence_scores: influenceScores
                            }
                        },
                        summary: `Fallback analysis complete. Found ${Object.keys(influenceScores).length} nodes with influence scores.`
                    };
                }
            });
            
            // Update dropdown for fallback
            updatePluginDropdown([{
                id: 'basic-analysis',
                name: 'Basic Analysis (Fallback)', 
                description: 'Simple JavaScript-based analysis when Python plugins fail'
            }]);
            
            console.log('Fallback analysis system initialized');
        }
        
        function formatAnalysisSummary(results) {
            const lines = [];
            
            if (results.influence_scores) {
                const scores = Object.entries(results.influence_scores);
                if (scores.length > 0) {
                    const topNode = scores.reduce((a, b) => a[1] > b[1] ? a : b);
                    lines.push(`Highest influence: ${topNode[0]} (${topNode[1]})`);
                }
            }
            
            if (results.positive_paths && results.positive_paths.length > 0) {
                lines.push(`Found ${results.positive_paths.length} positive path(s)`);
            }
            
            if (results.negative_paths && results.negative_paths.length > 0) {
                lines.push(`Found ${results.negative_paths.length} negative path(s)`);
            }
            
            return lines.length > 0 ? lines.join('. ') + '.' : 'Analysis completed successfully.';
        }

        function displayAnalysisResults(results) {
            const container = document.getElementById('results-content');
            
            let html = `<div style="margin-bottom: 15px;"><strong>Summary:</strong> ${results.summary}</div>`;
            
            // Show metadata if available
            if (results.metadata) {
                const meta = results.metadata;
                html += `<div style="margin-bottom: 15px; font-size: 12px; color: #666;">
                    <strong>Analysis:</strong> ${meta.analysis_name} | 
                    <strong>Nodes:</strong> ${meta.graph_stats?.nodes || 0} | 
                    <strong>Edges:</strong> ${meta.graph_stats?.edges || 0}`;
                
                if (meta.execution_time_ms) {
                    html += ` | <strong>Time:</strong> ${meta.execution_time_ms}ms`;
                }
                html += `</div>`;
            }
            
            if (results.results && results.results.primary) {
                const primary = results.results.primary;
                
                // Display influence scores
                if (primary.influence_scores && Object.keys(primary.influence_scores).length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Influence Scores:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    const sortedScores = Object.entries(primary.influence_scores)
                        .sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
                    
                    sortedScores.forEach(([node, score]) => {
                        const color = score > 0 ? 'green' : score < 0 ? 'red' : 'gray';
                        html += `<div><span style="color: ${color};">${node}: ${score}</span></div>`;
                    });
                    html += `</div></div>`;
                }
                
                // Display positive paths
                if (primary.positive_paths && primary.positive_paths.length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Positive Paths:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    primary.positive_paths.forEach(path => {
                        html += `<div>${path.join(' → ')}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // Display negative paths
                if (primary.negative_paths && primary.negative_paths.length > 0) {
                    html += `<div style="margin-bottom: 15px;">
                        <strong>Negative Paths:</strong>
                        <div style="margin-left: 10px;">`;
                    
                    primary.negative_paths.forEach(path => {
                        html += `<div>${path.join(' → ')}</div>`;
                    });
                    html += `</div></div>`;
                }
                
                // If no meaningful results, show raw data
                if (!primary.influence_scores && !primary.positive_paths && !primary.negative_paths) {
                    html += `<div><strong>Raw Results:</strong>
                        <pre style="font-size: 12px;">${JSON.stringify(primary, null, 2)}</pre></div>`;
                }
            }
            
            container.innerHTML = html;
        }

        function showStatus(message, type = 'info') {
            const container = document.getElementById('status-container');
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-message ${type}`;
            statusDiv.textContent = message;
            
            container.appendChild(statusDiv);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            const editorNetwork = window.graphApp.networks.editor;
            const analysisNetwork = window.graphApp.networks.analysis;
            
            if (editorNetwork) {
                editorNetwork.fit();
            }
            if (analysisNetwork) {
                analysisNetwork.fit();
            }
        });
    </script>
</body>
</html>